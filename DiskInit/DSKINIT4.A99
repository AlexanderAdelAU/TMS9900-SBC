;
;****************************************
;
;	DISK INITIALISER
;
;	THIS PROGRAMME WILL INITIALISE THE BAT ETC
;	VERSION 3 FOR IDE FIXED DISC INTERFACE
;	VERSION 4 COMPATIBLE WITH MODULE LOAD SECTOR, BUT NO CHANGE TO ACTUAL CODE
;	          VERSION REFLECTS THAT THIS IS PART OF THE 4 BASELINE.
;
;**************************************
;
;
R0	EQU	0
R1	EQU	1
R2	EQU	2
R3	EQU	3
R4	EQU	4
R5	EQU	5
R6	EQU	6
R7	EQU	7
R8	EQU	8
SL	EQU	9
SP	EQU	10
R11	EQU	11
PORT	EQU	12
R12	EQU	12
R13	EQU	13
R14	EQU	14
R15	EQU	15
;
;	DEFINE SOME XOP'S
;
	DXOP	CALL,6
	DXOP	RET,7
	DXOP	PUSH,8
	DXOP	POP,9
	DXOP	WHEX,10
	DXOP	WRITE,12			;WRITE CHAR IN MSB
	DXOP	READ,13			;READ CHAR IN MSB
	DXOP	MESG,14			;OUTPUT NULL TERMINATED MESSAGE
	DXOP	DEBUG,15		;DEBUG CURRENT LOCATION & STORE INTO DEBUG_BUFFER
;
;  OPERATING SYSTEM EQUATES
;
MONITOR	EQU	0F000H
SHELL_ADDR	EQU	0C300H

	AORG	0500H
	JMP	START

;
;---FCB ENTRY EQUATES
;
FLA	EQU	16			;LOAD ADDRESS	
CRN	EQU	26			;NEXT RECORD TO READ
FSB	EQU	12			;TWO BYTES HOLD TRACK AND SECTOR
FSZ	EQU	14			;NUMBER OF SECTORS TO LOAD
;
;NOTE THERE ARE NOW 12 SECTORS PER BLOCK
;SO SECTOR 2 IS THE FIRST BLOCK AFTER THE BOOT SECTOR
;
;SO WORD BELOW IS INTERPRETED AS
; FSB, FSZ AND FLA
;

;
;--SYSTEM DIRECTORY ENTRY BLOCKS.   THESE FILE DO NOT NEED A MODULE LOCATION INDEX TABLE
;
;
SHELLSYS	TEXT	'SHELL   SYS'
	BYTE	0			;FILE TYPE
	WORD	2,7,0C300H,0,0,0,0,0,0,0	;FSB,FSZ,FLA  4 SECT PER BLOCK MEANS 2 BATS IF 5
;
BDOSSYS	TEXT	'BDOS    SYS'
	BYTE	0
	WORD	4,7,0D100H,0,0,0,0,0,0,0 	;TWO BAT ENTERIES
;
;SAVE	TEXT	'SAVE    EXE'		;NOTE, DON'T LOAD SAVE
;	BYTE	2			;TYPE 2 IS EXECUTABLE
;	WORD	6,2,0100H,0,0,0,0,0,0,0 	;SAVE COMMAND ONE BAT ENTERY

;DIR	TEXT	'DIR     EXE'		;NOTE, DON'T LOAD SAVE
;	BYTE	2			;TYPE 2 IS EXECUTABLE
;	WORD	7,2,0C400H,0,0,0,0,0,0,0 	;SAVE COMMAND ONE BAT ENTERY

;
;BAT INITIALISER 
;
BATINT	WORD	0FF80H,0FF80H		;RESERVERD FOR BOOT,BAT AND DIRECTORY ENTRIES + FUTURE
	WORD	2,0FF80H		;SHELL [BLOCKS 2 AND 3]
	WORD	4,0FF80H		;BDOS [BLOCKS 4 AND 5]
;	WORD	0FFF8H		;SAVE [BLOCK 6]
	WORD	0		;END OF TABLE

RETRY	WORD	10		;RETRIES
;
; MONITOR AND SHELL EQUATES - THESE ARE ONLY USED BY LOADER
;
;WBOOT	EQU	MONITOR+10*4		;WARM BOOT
;SELDSK	EQU	MONITOR+4*4		;SELECT A DISK
;RECAL	EQU	MONITOR+5*4		;HOME THE DRIVE USED BY LOADER
;SEEK	EQU	MONITOR+6*4		;SEEK A TRACK - USED BY LOADER
;RDREC	EQU	MONITOR+7*4		;READ A SECTOR  USED BY LOADER
;WRREC	EQU	MONITOR+8*4		;WRITE A SECTOR
;RDID	EQU	MONITOR+9*4
;
BYTSEC	EQU	512			;BYTES PER SECTOR
SECBLK	EQU	4			;SECTOR PER BLOCK
;
;
;BATTRK	EQU	0			;START TRACK
;DIRTRK	EQU	0			;DIRECTORY STARTS HERE
;
; DEFINE LBA VALUES FOR DISK INIT
;

BOOT_LBA	EQU	0
BAT_LBA	EQU	2
DIR_LBA	EQU	8
FINAL_LBA	EQU	16
BLK2_LBA	EQU	18		; LBA = BLOCK_NUM* 4 * 2  FILES START AT BLOCK 2
				;AND THERE ARE 4 SECTORS PER BLOCK, AND 2 LBAS PER SECTOR
NDIRSEC	EQU	4			;NUMBER OF DIRECTORY SECTORS
NAMSIZ	EQU	11			;DIRECTORY NAME SIZE
;
;
;
;	AS WE ARE USING LOCAL WORKSPACE
;
	EVEN
START	LWPI	WORKSP		;USE LOCAL WORKSPACE
	LI	SP,STACKP
;	LI	SL,STACKL
	CALL	@IDE_READY
	CALL	@INITBOOT		;INITIALISE BOOT SECTOR
	CALL	@INITBAT		;INITIALISE BAT
	CALL	@INITDIR		;INITIALISE DIRECTORY
	CALL	@INITSYS		;INITIALISE SYSTEM FILES
	MESG	@SUCCESS
	BLWP	@MONITOR		;RETURN TO MONITOR ENTRY
	;
COPY2IMAGE	MOV	@IMAGEPTR,R3
	CALL	@READ_SECTOR
	AI	R3,BYTSEC
	MOV	R3,@IMAGEPTR
	RET
SUCCESS:	BYTE	0DH,0AH
	TEXT	"SUCCESS..."
	BYTE	0DH,0AH,0
	EVEN
;
;RETURN TO MONITOR ENTRY
;
;--INITIALISE THE BOOT SECTOR.  PASS THE ADDRESS OF THE LOADER IN R3, LBA IN R5
;
INITBOOT	LI	R3,LOADER		;ADDRESS OF LOADER MODULE
	LI	R5,BOOT_LBA		;BOOT LBA
	CALL	@WRITE_SECTOR		;WRITE OUT THE LOADER
	RET		
;
;
;INITIALISE THE BAT
;
;
INITBAT	LI	R1,IOBUF
	LI	R0,BYTSEC		;FLUSH BUFFER
IBAT1	CLR	*R1+		;CLEAR BAT ENTRY
	DECT	R0		;FINISHED ?
	JNE	IBAT1
;
;--BAT INITIALISER TABLE TRANSFERRED
;
	LI	R0,BATINT		;BAT ALLOCATION TABLE
	LI	R1,IOBUF
IBAT2	MOV	*R0+,*R1+		;ZERO INDICATES END OF TABLE
	JNE	IBAT2	
	LI	R5,BAT_LBA 		;GO TO NEXT LBA (REMEMBER INCREMENTS OF 2)
	LI	R3,IOBUF
	CALL	@WRITE_SECTOR		;WRITE OUT THE BUFFER

;
;	NEXT BAT SECTOR
;
	LI	R1,IOBUF
	LI	R0,BYTSEC		;INDEX TO LAST ENTRY
IBAT3	CLR	*R1+		;CLEAR BAT ENTRY
	DECT	R0		;FINISHED ?
	JNE	IBAT3
	INCT	R5		; R5 SHOULD BE UNTOUCHED SO INCREMENT BY 2 FOR NEXT LBA
	LI	R3,IOBUF
	CALL	@WRITE_SECTOR		;WRITE OUT THE BUFFER
;
; 	LAST BAT SECTOR
;
	LI	R1,IOBUF
	LI	R0,720-512 		;LAST BAT ENTRY
IBAT4	CLR	*R1+		;CLEAR BAT ENTRY
	DECT	R0		;FINISHED ?
	JNE	IBAT4
	SETO	*R1		;LAST LINK IS -1
	INCT	R5		;SEEK LAST LBA BAT
	LI	R3,IOBUF
	CALL	@WRITE_SECTOR
	RET
;
;--INITIALISE DIRECTORY SECTORS
;
INITDIR	LI	R0,0E5E5H		;NULL ENTRY BYTE
	LI	R1,IOBUF
	LI	R2,BYTSEC
IDIR1	MOV	R0,*R1+		;FILL BUFFER
	DECT	R2
	JNE	IDIR1
	CLR	R4
	LI	R5,DIR_LBA
;
IDIR2	LI	R3,IOBUF
	CALL	@WRITE_SECTOR		;WRITE OUT FIRST DIRECTORY BLOCKS
	INCT	R5		;GO TO NEXT LBA/SECTOR
	CI	R5,FINAL_LBA
	JLE	IDIR2
IDIR3	RET
;
;---INITIALISE SYSTEM FILES
;
INITSYS	LI	R8,IOBUF		;FCB ADDRESS
	LI	R3,SHELLSYS
	LI	R0,32*2		;FCB SIZE - JUST INIT SHELL and DOS
	MOV	R8,R1		;FCB ADDRESS
INTSYS2	MOVB	*R3+,*R1+		;TRANSFER DIRECTOR ENTRIES
	DEC	R0
	JNE	INTSYS2
	CLR	R4
	LI	R5,DIR_LBA		;FIRST DIRECTORY
	MOV	R8,R3		;DIRECTORY ENTRY ADDRESS
	CALL	@WRITE_SECTOR
;
;--NOW WRITE THE SYSTEM FILES THAT ARE IN MEMORY TO DISC
;
	LI	R8,IOBUF		;BEGIN WITH SHELL
	CLR	R4
	LI	R5,BLK2_LBA		;BLOCK 2 IS WHERE FILES BEGIN
	CALL	@WRTSYS
	AI	R8,32		;Use DIR Offset to now point to BDOS
	CALL	@WRTSYS
	RET			;ALL DONE
;
;--WRITE EACH SYSTEM FILE WHOSE FCB ADDRESS IS IN R8
;
WRTSYS:	CLR	@CRN(R8)
WRTSYS1	MOV	@CRN(R8),R3		;GET CURRENT RECORD NUMBER (SECTOR)
	MOV	@FSB(R8),R5		;GET FIRST BLOCK NUMBER NUMBER
	SLA	R5,3		;MULTIPLY BY 8, BLOCK_NUM * 2 * 4 TO GET LBA
	SLA	R3,1		;MULTIPLY BY 2 FOR TWO LBA RECORDS PER SECTOR (8 BIT ISSUE)
	A	R3,R5		;WE NOW HAVE THE LBA TO WRITE TO
	MOV	@FLA(R8),R3		;LOAD ADDRESS
	CALL	@WRITE_SECTOR		;READ IN A SECTOR
	LI	R0,BYTSEC
	A	R0,@FLA(R8)		;INCREMENT LOAD ADDRESS POINTER
	INC	@CRN(R8)
	DEC	@FSZ(R8)		;FINISHED ?
	JNE	WRTSYS1		;NO
	RET
;
;--------------------------------------------------------------------
;
;	LOADER MODULE - IT IS LOCATED AT THE FIXED MEMO LOCATION OF 1000H
;
;	THIS MODULE WILL BE LOADED IN THE DISK BOOT SECTOR
;	AND WILL BE EXECUTED BY THE COLD BOOT MODULE WITHIN
;	THE MONITOR.  THE LOADER MODULE IS RESPONSIBLE FOR 
;	SEARCHING FOR, AND LOADING SHELL.SYS, BDOS.SYS AND BIOS.SYS.
;
;	IT ASSUMES THAT MONITOR HAS BEEN CALLED AN INITIALISED AND IS
;	CALLED FROM THE MONITOR AND WILL USE MONITOR'S WORKSPACE
;
;	MODULE CANNOT BE LARGER THAT 512 BYTES SO WE MUST USE MONITOR DISC ROUTINES
;
;-------------------------------------------------------------------
	AORG	SHELL_ADDR - 2048	;LOCATE LOADER JUST ABOVE THE SEHLL
LOADER:	LWPI	WORKSP
	LI	SP,STACKP
	CALL	@IDE_READY
 	LI	R5,DIR_LBA		;SEEK DIRECTORY TRACK USING LBA VALUE
	LI	R3,IOBUF
	CALL	@READ_SECTOR		;READ IN THE DIRECTORY THROUGH MONITOR
	JLT	LOADERR	
;
;--LOOK FOR THE SYSTEM FILES, FIRST SHELL.
;

	LI	R8,IOBUF		;SHELL SYSTEM FIRST
	LI	R4,SHELL		;NAME OF SYSTEM FILES
	CALL	@MATCH
	JNE	LOADERR
	CALL	@LOADSYS		;LOAD SHELL SYSTEM
;
;	NOW LOAD BDOS
;
	AI	R8,32		;NEXT DIRECTORY ENTRY
	LI	R4,BDOS		;NAME OF SYSTEM FILES
	CALL	@MATCH
	JNE	LOADERR
	CALL	@LOADSYS		;LOAD BDOS SYSTEM
	B	@SHELL_ADDR		;INITAILISE INTERRUPT VECTORS ETC AND GO TO SHELL ENTRY RATHER THAN VECTOR
	
;
;--LOAD SYSTEM FILE
;
;  R8 -> FCB
;
LOADSYS:	CLR	@CRN(R8)
LOAD1	MOV	@CRN(R8),R3		;BEGIN AT FIRST RECORD	
	MOV	@FSB(R8),R5		;GET FILE STARTING BLOCK INDEX
	SLA	R5,3		;WE HAVE RELATIVE LBA NOW
	SLA	R3,1		;2 LBA RECORDS PER SECTOR 8 BIT ISSUE
	A	R3,R5		;NOW HAVE LBA
	MOV	@FLA(R8),R3		;LOAD ADDRESS
	CALL	@READ_SECTOR		;READ IN A SECTOR IN R3
	JNE	LOADERR
	INC	@CRN(R8)		;UP RECORD COUNT
	LI	R0,BYTSEC
	A	R0,@FLA(R8)		;INCREMENT LOAD ADDRESS POINTER
	DEC	@FSZ(R8)		;FINISHED ?
	JNE	LOAD1		;No
	RET
;
;--MATCH A DIRECTORY ENTRY
;	R4->NAME TO MATCH
;	R8->DIRECTORY ENTRY
;
MATCH	MOV	R8,R3
	SETO	R1		;ERROR FLAG
	LI	R0,NAMSIZ 		;NUMBER OF CHARS TO MATCH
MATCH1	CB	*R4+,*R3+		;CHECK FOR SYSTEM FILES
	JNE	MATCH2		;MATCH ERROR
	DEC	R0	
	JNE	MATCH1	 	;CONTINUE
	CLR	R1
MATCH2	MOV	R1,R1		;SET STATUS FLAGS
	RET

LOADERR 	MESG	@LDMSG
	BLWP	@MONITOR
;
;=========START OF IDE INTERFACE ROUTINES====================
;
;
; IDE REGISTERS - REFERENCE SEE THE SEAGATE REFERENCE MANUAL
;
IDE_BASE_PORT:	EQU	8040H	;PARALLEL OUTPUT ADDRESS WITH MSB SET THIS IS CS0
BYTEWIDE:	EQU	2
;
IDE_COMMAND:	EQU	IDE_BASE_PORT+7*2
IDE_STATUS:	EQU	IDE_BASE_PORT+7*2
IDE_CONTROL:	EQU	IDE_BASE_PORT+6*2
IDE_DATA:	EQU	IDE_BASE_PORT
IDE_HEAD:	EQU	IDE_BASE_PORT + 6*2
IDE_CYL_LSB:	EQU	IDE_BASE_PORT + 4*2
IDE_CYL_MSB:	EQU	IDE_BASE_PORT + 5*2
IDE_SECTOR:	EQU	IDE_BASE_PORT + 3*2
IDE_SEC_CNT:	EQU	IDE_BASE_PORT + 2*2
IDE_ERROR:	EQU	IDE_BASE_PORT + 1*2
;
; IDE STATUS REGISTER AND BIT DEFINTIONS
;
IDE_BSY:	EQU	10000000B		;80H
IDE_DRDY:	EQU	01000000B		;40H
IDE_ERR:	EQU	00000001B		;01H
IDE_DWF:	EQU	00100000B		;20H  DRIVE WRITE FAULT
IDE_DSC:	EQU	00010000B		;01H  DRIVE SEEK COMPLETE
IDE_DRQ:	EQU	000010000B		;01H  DATA REQUEST BIT
;
; IDE COMMANDS - NOTE COMMAND IS IN THE MOST SIGNIFICANT BYTE
;
IDE_CMD_READ:	EQU	02000H
IDE_CMD_WRITE:	EQU	03000H	;R = 0 FOR NO RETRY
IDE_CMD_RECAL:	EQU	01000H	;R = 0 FOR NO RETRY
IDE_CMD_INIT:	EQU	09100H
IDE_CMD_ID:	EQU	0EC00H	;GET THE DRIVE PROPERTIES
IDE_CMD_SDOWN:	EQU	0E000H	;R = 0 FOR NO RETRY
IDE_CMD_SUP:	EQU	0E100H	;R = 0 FOR NO RETRY

;
; CHECK THE IDE READY BIT.
;
IDE_READY:	LI	PORT, IDE_HEAD		;DEVICE HEAD REGISTER
	LI	R1, 11100000B*256	;SPECIFY LBA MODE
	LDCR	R1,BYTEWIDE		;WRITE THE COMMAND

	LI	PORT,IDE_COMMAND	;STATUS
BSY1:	STCR	R1,BYTEWIDE			;GET STATUS REGISTER
	ANDI	R1,10000000B * 256		;IF BUSY, THEN WAIT
	JNE	BSY1

	LI	PORT,IDE_COMMAND	;STATUS
RDY1:	STCR	R1,BYTEWIDE			;GET STATUS REGISTER
	ANDI	R1,01000000B * 256		;WAIT FOR RDY TO BE SET
	JEQ	RDY1
	RET

;when an error occurs, we get acc.0 set from a call to ide_drq
;or ide_wait_not_busy (which read the drive's status register).  If
;that error bit is set, we should jump here to read the drive's
;explaination of the error, to be returned to the user.  If for
;some reason the error code is zero (shouldn't happen), we'll
;return 255, so that the main program can always depend on a
;return of zero to indicate success.
;
IDE_GET_ERROR:	LI	PORT, IDE_ERROR
	CLR	R1
	STCR	R1,BYTEWIDE
	MOVB	R1,R1
	JEQ	IGE_X		;RETURN ERROR IN MSB OF R1
	MESG	@IDE_MSG1
	WHEX	R1
IGE_X	RET

IDE_MSG1:	TEXT	"IDE ERROR: "
	WORD	0DH,0AH,0
	EVEN
;
; READ SECTOR.
; LBA ORGANISED AS
; LBA + 0 = MSB OR DRIVE/HEAD; LBA + 1 = CYL LSB; LBA + 2 = CYL MSB; LBA + 3 = SECTOR
; R3 CONTAINS POINTER TO BUFFER
; R5 HOLDS THE LBA
;
READ_SECTOR:	MOV	R3,@BUFPTR
	CALL	@IDE_NOT_BUSY
	CALL	@IDE_WR_LBA
	LI	PORT, IDE_COMMAND	;COMMAND REGISTER6
	LI	R1, IDE_CMD_READ	; READ BUFFER
	LDCR	R1,BYTEWIDE
;
	CALL	@IDE_WAIT_DRQ
	JEQ	IDE_GET_ERROR
	CALL	@IDE_READ_DATA
	RET
;
;
; THE ADDRESS OF THE BUFFER IS IN R3 AND LBA IS IN R5
;
WRITE_SECTOR:	MOV	R3,@BUFPTR
	CALL	@IDE_NOT_BUSY
	CALL	@IDE_WR_LBA
	LI	PORT, IDE_COMMAND	;COMMAND REGISTER6
	LI	R1, IDE_CMD_WRITE	; WRITE BUFFER
	LDCR	R1,BYTEWIDE
;
	CALL	@IDE_WAIT_DRQ
	CALL	@IDE_WRITE_DATA
	CALL	@COPY2IMAGE
	RET
;
;  ENTER WITH R3 CONTAINING THE SECTOR.   FOR LOW NUMBER SECTORS ON THE FIRST TRACK THIS
;  SIMPLE APPROACH WILL WORK.
;  LBA = 2 * SECTOR_NUMBER FOR TRACK 0
;
GET_LBA:	RET
;
; WAIT FOR THE IDE DRIVE TO NOT BE BUSY
;
IDE_NOT_BUSY:	LI	PORT,IDE_COMMAND	;STATUS
BSY2	STCR	R1,BYTEWIDE			;GET STATUS REGISTER
	ANDI	R1,10000000B * 256		;IF BUSY, THEN WAIT
	JNE	BSY2
	RET
;
; WAIT FOR DRQ BEFORE READ DATA.  0 STATUS, ERROR
;
IDE_WAIT_DRQ:	SETO	R0		;VERY CRUDE TIMEOUT
	LI	PORT, IDE_COMMAND
	CLR	R1
DRQ1	DEC	R0
	JEQ	DRQ_X
	STCR	R1,BYTEWIDE
	ANDI	R1,00001000B * 256	;WAUT FOR DRQ  READT, THEN WAIT
	JEQ	DRQ1
DRQ_X	RET
;
; IDE Status Register:
; bit 7: Busy 1=busy, 0=not busy
;  bit 6: Ready 1=ready for command, 0=not ready yet
; bit 5: DF 1=fault occured inside drive
; bit 4: DSC 1=seek complete
; bit 3: DRQ 1=data request ready, 0=not ready to xfer yet
; bit 2: CORR 1=correctable error occured
; bit 1: IDX vendor specific
; bit 0: ERR 1=error occured
;;------------------------------------------------------------------
;
; BECAUSE IDE TRANSFERS ARE IN 16 BIT WORDS AND WE ONLY HAVE ACCESS TO 8 BIT
; TRANSFERS, 256 BYTES REPRESENTS A SECTOR.
;
;
;
IDE_READ_DATA:	MOV	@BUFPTR,R4
	LI	R0,512
	LI	PORT,IDE_DATA	 	;DATA REG
RL11:	STCR	R1,BYTEWIDE		;
	MOVB	R1,*R4+
	DEC	R0
	JNE	RL11
	RET
;
; BECAUSE IDE TRANSFERS ARE IN 16 BIT WORDS AND WE ONLY HAVE ACCESS TO 8 BIT
; TRANSFERS, 256 BYTES REPRESENTS A SECTOR.
;

IDE_WRITE_DATA:	MOV	@BUFPTR,R4
	LI	R0,512
	LI	PORT,IDE_DATA	 	;DATA REG
WL11:	MOVB	*R4+,R1
	LDCR	R1,BYTEWIDE		;
	DEC	R0
	JNE	WL11
	RET

;
; WRITE THE LOGICAL BLOCK ADDRESS TO THE DRIVE'S REGISTERS
; ORGANISED AS:
; LBA	WORD	0,0
;
; LBA + 3 = HEAD   (MSB)
; LBA + 2 = CYL MSB
; LBA + 1 = CYL LSB
; LBA + 0 = SECTOR (LSB )
; LBA VALUE PASSED IN R4 AND R5 (LSB)
;
IDE_WR_LBA:	CLR	@LBA
	MOV	R5,@LBA+2
	MOVB	@LBA+0,R1		;GET THE FIRST MSB BYTE
	ANDI	R1,0FH*256
	ORI	R1,0E0H*256		; 0EH IS JUST THE 1110 CODE FOR HEAD REGISTER
	LI	PORT,IDE_HEAD		; IDE HEAD
	LDCR	R1,BYTEWIDE
;
	MOVB	@LBA+1,R1
	LI	PORT,IDE_CYL_MSB	;CYLINDER MSB
	LDCR	R1,BYTEWIDE

	MOVB	@LBA+2,R1
	LI	PORT,IDE_CYL_LSB	;CYLINDER LSB
	LDCR	R1,BYTEWIDE

	MOVB	@LBA+3,R1
	LI	PORT,IDE_SECTOR		;CYLINDER LSB
	LDCR	R1,BYTEWIDE
;
; WE NEED TO READ TWO SECTORS TO GET 512 BYTES DUE TO THE FACT THAT WE CAN'T DO 16 BIT READS/WRITES
;
	LI	R1,2*256		;
	LI	PORT,IDE_SEC_CNT		;CYLINDER LSB
	LDCR	R1,BYTEWIDE
	RET
;
;
;--SYSTEM FILE NAMES
;
SHELL	TEXT	'SHELL   SYS'
BDOS	TEXT	'BDOS    SYS'
;
;--LOADER MESSAGES
;
LDMSG	BYTE	0DH,0AH,
	TEXT 	"Boot-no system files..."
	BYTE	0DH,0AH,00
	EVEN

	AORG	LOADER + 510
	WORD	LOADER		;THIS WILL PUT THE LOAD ADDRESS AS THE LAST WORD
SIZE:	EQU	$-LOADER
	BSS	512-SIZE
;
;---------END OF LOAD MODULE----SIZE < 512 BYTES -------------
;
;  BUFFER AND WORKSPACES REGIONS
;
NAMPTR	WORD	0
CDSEC	WORD	0		;CURRENT DIRECTORY SECTOR
BUFPTR	WORD	0
WORKSP	BSS	32
STACKL	BSS	16
STACKP  	EQU	$-2
IOBUF	BSS	512
;
LBA:	BSS	4
IMAGEPTR	WORD	2000H
	AORG	2000H
IMAGE:	BSS	2048
	END



	END
