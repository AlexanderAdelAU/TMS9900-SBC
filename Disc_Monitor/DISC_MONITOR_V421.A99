;
;-----------------------------------------------------------------------
;	MONITOR AND FDC INTERFACE ROUTINES for the TI99000 SBC
;
;	 Written by Alex Cameron
;
;	The monitor routines are called from a DOS or other
;	programme to perform Console I/O and Disc I/O similar
;	to a BIOS.
;
;	Version 2.1	14th May 2020 - The year of the Corona Virus
;	Version 2.2	3rd February, 2024 -
;		Combined partial set of TIBUG commands into Monitor
;		and targeted for the SBC ROM.
;		RAM ADDRESS: EC00H-EFFFH;
;		ROM ADDRESS: F000H-FFFFH
;	VERSION 3.0	9th June, 2024
;		Support added to allows for a IDE/SATA interface using LBA sectors.
;	VERSION 4.1	29th July, 2024
;		Support segmented memory model and removal of Floppy Disc Code
;	VERSION 4.21	7th September, 2024
;		Support segmented memory model extension of a PSEL SET AND CLEAR
;
;---------------------------------------------------------------------
;
R0	EQU	0
R1	EQU	1
R2	EQU	2
R3	EQU	3
R4	EQU	4
R5	EQU	5
R6	EQU	6
R7	EQU	7
R8	EQU	8
R9	EQU	9		;Use to index workspace pointer not stack overflow
;SL	EQU	R9		;STACK LIMIT
R10	EQU	10
SP	EQU	R10		;STACK POINTER
R11	EQU	11
R12	EQU	12
PORT	EQU	R12		;IO BASE
R13	EQU	13
R14	EQU	14
R15	EQU	15
ST	EQU	15
;
;***************************************************
;
;	DEFINE SOME XOP'S.
;	ALL PROGRAMMES USE THESE XOPS
;
;****************************************************
;
	DXOP	PSEL,0
	DXOP	RETF,1
	DXOP	NEWPAGE,2
	DXOP	SWBANK,3
	DXOP	PUSHREG,4		;PUSH RANGE OF REGISTERS TO STACH
	DXOP	POPREG,5
	DXOP	CALL,6
	DXOP	RET,7
	DXOP	PUSH,8		;PUSH SINGLE REGISTER
	DXOP	POP,9
	DXOP	WHEX,10		;WRITE OUT A 16 BIT HEX VALUE
	DXOP	RHEX,11		;READ IN A 16 BIT HEX VALUE
	DXOP	WRITE,12		;WRITE CHAR IN MSB
	DXOP	READ,13		;READ CHAR IN MSB
	DXOP	MESG,14		;OUTPUT NULL TERMINATED MESSAGE
	DXOP	DEBUG,15		;DEBUG CURRENT LOCATION & STORE INTO DEBUG_BUFFER
;
; SOME EQUATES.  NOTE WORKSP MUST BE IN COMMON MEMORY
;
MONORG:	EQU	0F000H		;ORIGIN FOR THIS MONITOR
INTVEC:	EQU	0000H		;START AT THE TOP
XOPVEC:	EQU	0040H
INTWP:	EQU	00B0H		;;7 INT AND 16 XOPS WORKSPACES OF 16 BYTES EACH
XOPWP:	EQU	0130H		;XOP WORKSPACE ALLOCATION FOR ALL XOPS
WORKSP:	EQU	0230H		;USE AREA BELOW XOP WORKSPACES - 32 BYTES
STACKP:	EQU	0500H		;COMMON STACK USED BY ALL PROGRAMMES
MON_PTR:	EQU	0088H		;MONITOR VECTOR.  PROGRAMMES CAN USE THIS
TPA:	EQU	0500H		;PROGRAME LOAD AREA
;
; THIS IS WHERE THE LBA (TWO WORDS) ARE STORED SO IT CAN BE LOADED
;
LBA:	EQU	0A8H		;TWO WORDS (4 BYTES)

;
; DECLARE VARIABLES THAT NEED RAM
;
BUFFER:	EQU	MONORG-0300H		;THIS IS A TEMPORARY BUFFER USED BY BOOT
LOCAL_RAM: 	EQU	MONORG-0100H
	AORG	LOCAL_RAM
	BSS	32
;
;	NOTE THIS IS USED BY DEBUG TO STORE MULTIPLE DEBUG POINTERS TO
;	PROGRAMMES CALLING DEBUG
;
DEBUG_NAME:	BSS	10		;;NAME OF MODULE 8 CHARS LONG NULL TERMINATED
DEBUG_BUFFER:	BSS	20		;DEBUG TRACE LIST

;
;-- RAM BASED IO PARAMETER BLOCK - NOT USED WITH IDE
;
	EVEN
DISC_PARAM:	EQU	$ + 0
FDCSTATUS:	WORD	0	 	;OPERATION STATUS
TIMEOUT:	WORD 	1		;N * 16MS DURATION
DISC_INUSE:	WORD	0

RAM_SIZE:	EQU	$ - DISC_PARAM

;	AORG	0400H
;	SETO	R9		;CLEAR SEGEMENT AND SELECT PAGE 0
;	LI	PORT,MEMBASE
;	LDCR	R9,BYTEWIDE		;GET PAGE VALUE FROM STEP ABOVE
;	BLWP	@INIT_MONITOR
;
;;-----TESTING CODE
;	AORG	0500H
;	BLWP	@TEMP
;TEMP:	WORD	WORKSP
;	WORD	INITIAL


;----- END TESTING CODE
;
; LOCATE THE MONITOR IN MEMORY
;
	AORG	MONORG
;
; INITIALISATION
;
;
;************************************************************************************
;
;	USE BLWP @MONITOR TO INITIALISE MONITOR VECTORS AND INTERRUPTS
;
;	NOTE ALL PROGRAMMES OR MODULES MUST SET THEIR WORSPACE
;	POINTERS AND STACKS BEFORE CALLING, e.g.
;
;	AORG 0100H
;	LWPI WORKSP
;	BLWP @INIT_MONITOR
;	<INITIALISED MONITOR WILL RETURN HERE>
;
;
;*************************************************************************************
;
INIT_MONITOR:
	WORD	WORKSP		;THIS IS MONITOR WORKSAPCE
	WORD	INITIAL		;INITIALISE ALL XOP, INTERRUPT AND ENTRY VECTORS
BOOT_ADDR:	B	@BOOT		;PERFORM A COLD BOOT - POS IN TABLE HELPS DEBUGGING
	B	@CIN		;CHAR IN
	B	@COUT		;CHAR OUT
	B	@SELDSK		;SELECT A DISK DRIVE
	B	@RECAL	 	;RECALIBRATE DRIVES
	B	@SEEK		;SEEK THE TRACK IN R3
	B	@RDREC		;READ SELECTED SECTOR
	B	@WRREC	 	;WRITE SELECTED SECTOR
	B	@RDID		;READ TRACK ID ADDRESS
	B	@WBOOT		;PERFORM A WARM BOOT
	B	@RDTRK		;READ A TRACK OF DATA
	B	@WRTRK		;WRITE A TRACK OF DATA

;
;**********************************************************
;
;	DMA PARAMETER BLOCK DEFINITIONS
;	INDEXED DEPENDING ON READ(0), OR WRITE(1) COMMAND
;
;************************************************************
;
CMDTBL:	STCR	*R8+,BYTEWIDE	;BYTE WIDE FDC DATA READ
	LDCR	*R8+,BYTEWIDE	;BYTE WIDE FDC DATA WRITE
;
;--REGISTERS IN INTERRUPT 3 WORKSPACE
;
DMACMD	SET	2*R9+INTWP2		;CURRENT COMMAND
DMAADDR 	SET	2*R8+INTWP2		;REGISTER HOLDING SOURCE ADDRESS
DMAPORT	SET	2*R12+INTWP2	;IO BASE REG I.E. DATAREG

CRLF	BYTE	0DH,0AH,0
	EVEN
;
;FDC 1797 COMMANDS
;
;RDCMD:	EQU	10001000B 		;READ CMD
;RIDCMD:	EQU	11000000B	 	;READ ID
;WRCMD:	EQU	10101000B 		;WRITE CMD
;WTCMD:	EQU	11110000B		;WRITE TRACK
;RTCMD:	EQU	11100000B		;READ TRACK
;SEKCMD:	EQU	00011100B 		;SEEK CMD
;RSTCMD:	EQU	00001100B	 	;RESTORE COMMAND
;FINTCMD:	EQU	11010000B		;FORCE INTERRUPT COMMAND
;SICMD:	EQU	01011100B		;STEP IN COMMAND
;SOCMD:	EQU	01111100B		;STEP OUT COMMAND
;
;--FDC 1797 IO REG LOCATIONS.  SET BY ADDRESS BITS A13,A14   HENCE 2, 4 6
;
FDC1797:	EQU	8000H		;IO BASE REGISTER- BYTE TRANSFER WITH MSB SET
STSREG:	EQU	FDC1797+0 		;MAIN STATUS REG
;CMDREG:	EQU	FDC1797+0 		;COMMAND REGISTER
;TRKREG:	EQU	FDC1797+2		;TRACK REGISTER
;SECREG:	EQU	FDC1797+4		;SECTOR REGISTER
;DATREG:	EQU	FDC1797+6		;DATA REGISTER
;
; BANK SWITCHING PORT
;
MEMBASE:	EQU	80C0H		;BASE MEMORY BANK SWITCH PORT
;
;
;--PORTS ETC.
;
SELMUX:	EQU	0		;SELECT CONTROL PORT (R12 CRU PORT)
;TYPMUX:	EQU	SELMUX + 2*5	;START AT BIT 5
BYTEWIDE:	EQU	2		;PARALLEL I/O DONE IN BYTES (UNIQUE TO 99105)
;
;
; THESE ARE THE TIBUG BASIC COMMANDS, SUCH AS:
; QBOOT, ADDR G(O), ADDR O(UTPUT), W(ORKSPACE), R(EGISTERS), ADDRESS O(PEN).
;
; TIBUG WILL BE THE DEFAULT ENTRY POINT.
; BOOTING IS EFFECTED BY ISSUING THE Q(QBOOT) COMMAND
;
;TIBUG_ENTRY: AND WE CAN NOW ENABLE INTERRUPTS
;
BANNER	LIMI	7		;ENABLE INTERRUPTS
	MESG	@MESS00		;_PRINT ">> TMS9900 TIBUG <<"
PROMPT	MESG	@MESS01		;PRINT PROMPTER
	BL	@HEXIN		;OBTAIN ADDRESS IN R2 AND INSTRUCTION IN R1
	LI	R4,20		;20 POSSIBLE INSTRUCTIONS
MON01	CB	@INTAB(R4),R1		;SEARCH INTAB
	JEQ	MON03
	DEC	R4
	JOC	MON01
MON02	MESG	@MESS02		;PRINT " ??"
	JMP	PROMPT
MON03	SLA	R4,1		;BRANCH TO APPROPRIATEE ROUTINE
	MOV	@SUBTAB(R4),R4	;
	MOV	R3,R3		;TEST HEXIN FLAG
	B	*R4
;
;  TIBUG INSTRUCTION TABLE
;
HEXTAB	TEXT	'0123456789ABCDEF'
NUMTAB	TEXT	'0 1 2 3 4 5 6 7 8 9 101112131415'
INTAB	BYTE	1AH		;CONTROL Z(CLEARS SCREEN) AND VERSION
	TEXT	'//QUVGMZOWRPXLHST/. '
	EVEN
SUBTAB	WORD	BANNER,0,0,QBOOT,HEXLOAD,HEXLOAD2,GO,MOVE,FIND,OUTPUT,WP,PRINT_REGS,PRINT
	WORD	XCUTE,LOWW,SETBP,SSTEP,TRACE,CHAR,INSTANT,OPEN


	;
	; COMMANDS IMPLEMENTED IN DISC_MONITOR
	; REGIST, OPEN, GO AND QBOOT.
	;
;MASK32	WORD	001FH
MASK15	WORD	000FH
;MASK8	WORD	0007H
MASK3	WORD	0003H
;
; DUMMY LIST
;
SSTEP:	JMP	PROMPT;   NULL COMMAND
SETBP:	JMP	PROMPT;   NULL COMMAND
TRACE:	JMP	PROMPT;   NULL COMMAND
CHAR:	JMP	PROMPT;   NULL COMMAND
MOVE:	JMP	PROMPT;   NULL COMMAND
FIND:	JMP	PROMPT;   NULL COMMAND
XCUTE:	JMP	PROMPT;   NULL COMMAND
LOWW:	JMP	PROMPT;   NULL COMMAND
INSTANT:	JMP	PROMPT;   NULL COMMAND
PRINT:	JMP	PROMPT;   NULL COMMAND
;
;ONLY THESE ONES HAVE BEEN IMPLEMENT WITHIN THE DISC_MONITOR ROM.  AS
;THE ADDRESS SPACE HAS BEEN TAKEN UP WITH THE DISC-IO AND THE OTHER FUNCTIONS
;CAN BE EASILY IMPLEMENTED WITH DISC BASED PROGRAMMES.
;
;QBOOT:	JMP	PROMPT;   NULL COMMAND
;GO:	JMP	PROMPT;   NULL COMMAND
;OUTPUT:	JMP	PROMPT;   NULL COMMAND
;WP:	JMP	PROMPT;   NULL COMMAND
;PRINT_REGS: JMP	PROMPT;   NULL COMMAND
;OPEN:	JMP	PROMPT;   NULL COMMAND
;
; MESSGES AND OTHER EQUATES
;
MESS00	BYTE	CR,LF
	TEXT	'<TMS9900 DISC MONITOR V4.21>'
;	BYTE	0
MESS01	BYTE	CR,LF
	TEXT	'>'
	BYTE	0
MESS02	TEXT	'??'
	BYTE	0
MESS03	BYTE	LF,CR,LF
	TEXT	'    '
	BYTE	0
MESS04	TEXT	' = '
	BYTE	0
;
CR:	EQU	0DH		;CARRIAGE RETURN
LF:	EQU	0AH		;LINE FEED
	EVEN

;
;*********************************
; SUPPORT ROUTINES FOR INPUT AND OUTPUT
;**********************************
;
;
; SUBROUTINE HEXIN
; INPUTS A HEX NO. INTO R2
; AND INSTRUCTION INTO R1
; (INSTRUCTION ' ' INSERT AND MOVE TO NEXT ADDRESS
; (INSTRUCTION '-' INSERT AND MOVE TO PREVIOUS ADDRESS
; THE HEX INDEX USES THE TRANSLATE TABLE HEXTAB TO IDENTIFY THE HEX DIGIT.
; THE LAST CHARACTER, EITHER SPACE OR - BREAKS THE CYCLE AS THEY ARE NOT IN THE HEXTABLE
;
; USES R1,R2,R3,R4
;
HEXIN:	CLR	R1
	CLR	R2
	SETO	R3		;SET FLAG
HEXIN0	READ	R1		;GET CHARACTER
	WRITE	R1		;PRINT CHARACTER
	LI	R4,15
HEXIN1	CB	@HEXTAB(R4),R1
	JNE	HEXIN2
	CLR	R3		;CLEARS FLAG
	SLA	R2,4		;SHIFTS HEX DIGIT INTO R2
	SOC	R4,R2
	JMP	HEXIN0
HEXIN2	DEC	R4
	JOC	HEXIN1		;SUBTRACTING 1 FROM 0 DOES NOT RESULT IN CARRY
	MOV	R3,R3		;TEST HEXIN FLAG
	RT			;RETURN FROM BL
;
; SUBROUTINE HEXOUT			;OUTPUT CONTENTS OF R2
; USES R0,R1,R2,R3
;
;HEXOUT	WRITE	@MESS03+7		;PRINTS " "
;HEXOUT0	PUSHREG	R3		;SAVE R0-R3
;HEXOUTX	CLR	R0
;	LI	R3,4
;HEXOUT1	SRC	R2,12
;	MOV	R2,R1
;	ANDI	R1,000FH
;	MOVB	@HEXTAB(R1),R0
;	WRITE	R0
;	DEC	R3
;	JNE	HEXOUT1
;	POPREG	R3		;RESTORE R3-R0
;	RT
;
DOT:	BYTE	'.',0
PLUS	BYTE	'+',0
LOADERR:	TEXT	'LOAD ERROR'
	BYTE	0
	EVEN
;
;**********************************************
;  XOP WP ENTRY POINTS
;**********************************************
;
XOPTAB:	WORD	XOPWP0,XOP0,XOPWP1,XOP1,XOPWP2,XOP2,XOPWP3,XOP3
	WORD	XOPWP4,XOP4,XOPWP5,XOP5,XOPWP6,XOP6,XOPWP7,XOP7,XOPWP8,XOP8
	WORD	XOPWP9,XOP9,XOPWP10,XOP10,XOPWP11,XOP11
	WORD	XOPWP12,XOP12,XOPWP13,XOP13,XOPWP14,XOP14,XOPWP15,XOP15
;
INTTAB:	WORD	WORKSP,INITIAL,INTWP1,INT1,INTWP2,FDC_RWINT, INTWP3,FDC_DRQ	;FDC1797 INTERUPT VECTORS
	WORD	INTWP4,INTTIMER,INTWP5,IDE_IRQ, INTWP6, IDE_DMARQ, INTWP7,INT7 	;TIMER INTERRUPT
;
INT1:	;LI	R0,1
	;WHEX	R0
	RTWP
INT7:	;LI	R0,7
	;WHEX	R0
	RTWP
;
;	NOTE.  APPLICATIONS MUST CALL WITH THEIR WP POINTERS SET
;	THIS CALL IS USED TO SET UP MONITOR AND IS CALLED USING BL
;	CALLED USING BLWP @MONITOR
;
INIT_VECTORS:	RSET			;CLEAR INTERRUPT MASK
;	LWPI	WORKSP		;USE MONITOR LOCAL WORKSPACE
;	LI	SP,STACKP		;STACK FOR LOCAL MONITOR USE
;
;	LI	R0,MON_PTR		;SET UP THE MONITOR POINTER
;	LI	R1,MONORG
;	MOV	*R1+,*R0+		;MOVE WORKSPACE POINTER
;	MOV	*R1+,*R0+		;MOVE MONITOR INITIALISATION ADDRESS
;
;************************************************************
;
;	SWTICH TO MONITOR XOP VECTORS RATHER THAN TIMON ROM
;	THIS MEANS THAT ALL PROGRAMMES THAT USE XOP WILL USE THE
;	THE XOP IMPLEMENTATIONS DEFINED IN MONITOR THAT IS HERE!
;
;************************************************************

	LI	R0,INTVEC		;SET UP INTERRUPT VECTORS
	LI	R1,INTTAB		;ONLY INT 0 TO 7
INIT1:	MOV	*R1+,*R0+
	MOV	*R1+,*R0+
	CI	R0,INTVEC+8*4		;8 INTERRUPT VECTORS
	JNE	INIT1
;
;ZERO UNUSED INTERRUPT WORDS AND OTHER INITIALISATION AREAS UP TO TPA
;
	LI	R0,INTWP0
	LI	R1,TPA
INIT2:	;CLR	*R0+
	;C	R0,R1
	;JNE	INIT2
;
;INITIALISE XOP-START AT XOP0, INTO MEMORY LOCATION AT 40H
;
	LI	R0,XOPVEC
	LI	R1,XOPTAB
INIT3:	MOV	*R1+,*R0+
	MOV	*R1+,*R0+
	CI	R0,80H		;FINISHED?
	JNE	INIT3		;NO
;
;Now initialise DISC and OTHER RAM.  FIRST ZERO THEN COMPY PRESETS
;
	LI	R0,RAM_SIZE
	LI	R1,DISC_PARAM
	CLR	R2
INIT_RAM	MOVB	R2,*R1+
	DEC	R0
	JNE	INIT_RAM
;
; NOW MOVE PRESETS
;
	SETO	R0
	INC	@TIMEOUT		;THIS JUST SETS TIMEOUT TO 1 AS IT IS ALREAY 0
	RT
;
;************************************************************
;
;	WARM BOOT ASSUMES A COLD BOOT HAS ALREADY OCCURED
;	AND DISC IS JUST BEING CALIBRATED TO A KNOWN STATE
;
;************************************************************
;
WBOOT:	JMP	BOOT
;
;*********************************************************
;
;	BOOT ASSUMES MONITOR HAS BEEN INITIALISED AND SO
;	THE FDC AND INTERRUPT VECTORS ARE IN VALID
;
;***********************************************************
;
BOOT:	MESG	@BMSG2
	CLR	R2
	CALL	@IDE_READY
;
;BOOT SECTOR IS LBA = 0
;
	CLR	R3		;BOOT LBA SECTOR
	LI	R4,BUFFER		;USE THIS AREA TO BOOT
	CALL	@READ_SECTOR
	JNE	BOOT2
;
; GET THE LOAD ADDRESS WHICH IS LOCATED AT THE LAST 2 BYTES OF THE LOADER BUFFER
;
	MOV	@BUFFER+510,R4
	MOV	R4,R0
	LI	R1,BUFFER
	LI	R2,512
BOOT1	MOV	*R1+,*R4+
	DECT	R2
	JNE	BOOT1
	LWPI	WORKSP		;RESET USE MONITOR LOCAL WORKSPACE
	LI	SP,STACKP
	B	*R0		;LET THERE BE LIFE - LOAD THE SYSTEM
;
; --BOOT ERROR
;
BOOT2	MOV	R1,@FDCSTATUS
	MESG	@BMSG1
	B	@PROMPT
;
BMSG1	TEXT	'--Boot error'
	BYTE	0DH,0AH,0
	EVEN
BMSG2	TEXT	'--Booting....'
	BYTE	0DH,0AH,0
PAGE	TEXT	"PAGE: "
	BYTE	0
	EVEN

;
;****************************
;
; CHAR IN (MSB	OF R1)
;
;*****************************
CIN	READ	R1	 	;GET CHAR
	RET
;*******************************
;
;	CHAR OUT (MSB OF R2)
;
;********************************
;
COUT	CLR	R1
	MOVB	R2,R1	 	;COPY CHAR TO R1
	WRITE	R1	 	;OUTPUT IT
	RET
;
;************************************************
;
;	SELECT THE DRIVE IN R2
;
;************************************************
;
SELDSK:	B	@IDE_READY

;
;*****************************
;
;--RECAL IS JUST SEEK TO TRK ZERO (RECAL IS HANDLED THERE)
;
;*****************************
;
RECAL:	RET

;*******************************
;
;READ ID FIELDS
;
;******************************
;
RDID	RET

;****************************
;
;READ A RECORD
; 	R3 HOLDS SECTOR
;	R4 HOLDS BUFFER POINTER
;
;*****************************
;
RDREC:	B	@READ_SECTOR

;****************************
;
;READ A TRACK
; 	R3 NOT REQUIRED
;	R4 HOLDS BUFFER POINTER
;
;*****************************
;
RDTRK	RET
;
;
;****************************
;
;WRITE A TRACK
; 	R3 NOT REQUIRED
;	R4 HOLDS BUFFER POINTER
;
;*****************************
;
WRTRK	RET

;******************************
;
;WRITE A RECORD
; 	R3 HOLDS SECTOR/LBA
;	R4 HOLDS BUFFER POINTER
;
;*****************************
;
WRREC	B	@WRITE_SECTOR

;
;=========START OF IDE INTERFACE ROUTINES====================
;
;
; IDE REGISTERS - REFERENCE SEE THE SEAGATE REFERENCE MANUAL
;
; IDE I/O ports
IDE_BASE_PORT:	EQU	8040H	;PARALLEL OUTPUT ADDRESS WITH MSB SET THIS IS CS0

IDE_COMMAND:	EQU	IDE_BASE_PORT+7*2
IDE_STATUS:	EQU	IDE_BASE_PORT+7*2
IDE_CONTROL:	EQU	IDE_BASE_PORT+6*2
IDE_DATA:	EQU	IDE_BASE_PORT
IDE_HEAD:	EQU	IDE_BASE_PORT + 6*2
IDE_CYL_LSB:	EQU	IDE_BASE_PORT + 4*2
IDE_CYL_MSB:	EQU	IDE_BASE_PORT + 5*2
IDE_SECTOR:	EQU	IDE_BASE_PORT + 3*2
IDE_SEC_CNT:	EQU	IDE_BASE_PORT + 2*2
IDE_ERROR:	EQU	IDE_BASE_PORT + 1*2
;
; IDE STATUS REGISTER AND BIT DEFINTIONS
;
IDE_BSY:	EQU	10000000B		;80H
IDE_DRDY:	EQU	01000000B		;40H
IDE_ERR:	EQU	00000001B		;01H
IDE_DWF:	EQU	00100000B		;20H  DRIVE WRITE FAULT
IDE_DSC:	EQU	00010000B		;01H  DRIVE SEEK COMPLETE
IDE_DRQ:	EQU	000010000B		;01H  DATA REQUEST BIT
;
; IDE COMMANDS - NOTE COMMAND IS IN THE MOST SIGNIFICANT BYTE
;
IDE_CMD_READ:	EQU	02000H
IDE_CMD_WRITE:	EQU	03000H	;R = 0 FOR NO RETRY
IDE_CMD_RECAL:	EQU	01000H	;R = 0 FOR NO RETRY
IDE_CMD_INIT:	EQU	09100H
IDE_CMD_ID:	EQU	0EC00H	;GET THE DRIVE PROPERTIES
IDE_CMD_SDOWN:	EQU	0E000H	;R = 0 FOR NO RETRY
IDE_CMD_SUP:	EQU	0E100H	;R = 0 FOR NO RETRY

BYTSEC:	EQU	512
;
; CHECK THE IDE READY BIT.
;
IDE_READY:	LI	PORT, IDE_HEAD		;DEVICE HEAD REGISTER
	LI	R1, 10100000B*256	;SPECIFY LBA MODE
	LDCR	R1,BYTEWIDE		;WRITE THE COMMAND

	LI	PORT,IDE_STATUS		;STATUS
BSY1:	STCR	R1,BYTEWIDE		;GET STATUS REGISTER
	ANDI	R1,10000000B * 256	;IF BUSY, THEN WAIT
	JNE	BSY1

	LI	PORT,IDE_STATUS		;STATUS
RDY1:	STCR	R1,BYTEWIDE			;GET STATUS REGISTER
	ANDI	R1,01000000B * 256		;WAIT FOR RDY TO BE SET
	JEQ	RDY1
	RET
;
; TEMPORARY INTERRUPT HANDLERS
;
IDE_IRQ:	;LI	R0,5
	;WHEX	R0
	LI	PORT,IDE_STATUS		;STATUS
	STCR	R0,BYTEWIDE
	RTWP
;
; TEMPORARY INTERRUPT HANDLERS
;
IDE_DMARQ:	;LI	R0,6
	;WHEX	R0
	LI	PORT,IDE_STATUS		;STATUS
	STCR	R0,BYTEWIDE
	RTWP

;
; CALL THE DRIVE ID.  THIS IS NOT OF MUCH PRACTICAL USE, BUT A GOOD TEST.
;
DRIVE_ID:	CALL	@IDE_READY
	LI	PORT, IDE_COMMAND	;COMMAND REGISTER6
	LI	R1, IDE_CMD_ID		; READ BUFFER
	LDCR	R1,BYTEWIDE
	CALL	@IDE_WAIT_DRQ
	JEQ	IDE_GET_ERROR
	CALL	@IDE_READ_DATA
	RET
;
;when an error occurs, we get acc.0 set from a call to ide_drq
;or ide_wait_not_busy (which read the drive's status register).  If
;that error bit is set, we should jump here to read the drive's
;explaination of the error, to be returned to the user.  If for
;some reason the error code is zero (shouldn't happen), we'll
;return 255, so that the main program can always depend on a
;return of zero to indicate success.
;
IDE_GET_ERROR:	LI	PORT, IDE_ERROR
	CLR	R1
	STCR	R1,BYTEWIDE
	MOVB	R1,R1
	JEQ	IGE_X		;RETURN ERROR IN MSB OF R1
	MESG	@IDE_MSG1
	WHEX	R1
IGE_X	RET

IDE_MSG1:	TEXT	"IDE ERROR: "
	WORD	0DH,0AH,0
	EVEN
;
; READ_SECTOR
;	R3 HOLDS THE LSB OF THE LBA VALUE FOR THE SECTOR WE WANT TO READ
;	R4 HOLDS THE BUFFER ADDRESS
;
READ_SECTOR:	MOV	R3,R5		;SAVE THE LBA
	CALL	@IDE_NOT_BUSY
	CALL	@IDE_WR_LBA
	LI	PORT, IDE_COMMAND	;COMMAND REGISTER6
	LI	R1, IDE_CMD_READ	; READ BUFFER
	LDCR	R1,BYTEWIDE
;
	CALL	@IDE_WAIT_DRQ
	JEQ	IDE_GET_ERROR
	CALL	@IDE_READ_DATA
	RET
;
; 	WRITE SECTOR
;	R3 HOLDS THE LSB OF THE LBA VALUE FOR THE SECTOR WE WANT TO READ
;	R4 HOLDS THE BUFFER ADDRESS
;
;
WRITE_SECTOR:	MOV	R3,R5
	CALL	@IDE_NOT_BUSY
	CALL	@IDE_WR_LBA
	LI	PORT, IDE_COMMAND	;COMMAND REGISTER6
	LI	R1, IDE_CMD_WRITE		; WRITE BUFFER
	LDCR	R1,BYTEWIDE
;
	CALL	@IDE_WAIT_DRQ
	CALL	@IDE_WRITE_DATA
	RET
;
; WAIT FOR THE IDE DRIVE TO NOT BE BUSY
;
IDE_NOT_BUSY:	LI	PORT,IDE_COMMAND	;STATUS
BSY2	STCR	R1,BYTEWIDE			;GET STATUS REGISTER
	ANDI	R1,10000000B * 256		;IF BUSY, THEN WAIT
	JNE	BSY2
	RET
;
; WAIT FOR DRQ BEFORE READ DATA.  0 STATUS, ERROR
;
IDE_WAIT_DRQ:	SETO	R0		;VERY CRUDE TIMEOUT
	LI	PORT,IDE_COMMAND
	CLR	R1
DRQ1	DEC	R0
	JEQ	DRQ_X
	STCR	R1,BYTEWIDE
	ANDI	R1,00001000B * 256	;WAUT FOR DRQ  READT, THEN WAIT
	JEQ	DRQ1
DRQ_X	RET
;
; IDE Status Register:
; bit 7: Busy 1=busy, 0=not busy
;  bit 6: Ready 1=ready for command, 0=not ready yet
; bit 5: DF 1=fault occured inside drive
; bit 4: DSC 1=seek complete
; bit 3: DRQ 1=data request ready, 0=not ready to xfer yet
; bit 2: CORR 1=correctable error occured
; bit 1: IDX vendor specific
; bit 0: ERR 1=error occured
;;------------------------------------------------------------------
;
; BECAUSE IDE TRANSFERS ARE IN 16 BIT WORDS AND WE ONLY HAVE ACCESS TO 8 BIT
; TRANSFERS, 256 BYTES REPRESENTS AN LBA AND TWO LBA A SECTOR.  SO TWO LBAS ARE READ
;
; WE ENTER WITH R4 -> BUFFER
;
IDE_READ_DATA:	LI	R0,BYTSEC
	LI	PORT,IDE_DATA	 	;DATA REG
RL11:	STCR	R1,BYTEWIDE		;
	MOVB	R1,*R4+
	DEC	R0
	JNE	RL11
	MOV	R0,R1
	RET
;
; BECAUSE IDE TRANSFERS ARE IN 16 BIT WORDS AND WE ONLY HAVE ACCESS TO 8 BIT
; TRANSFERS, 256 BYTES REPRESENTS AN LBA AND TWO LBA A SECTOR.
;
; WE ENTER WITH R4 -> BUFFER

IDE_WRITE_DATA:	LI	R0,BYTSEC
	LI	PORT,IDE_DATA	 	;DATA REG
WL11:	MOVB	*R4+,R1
	LDCR	R1,BYTEWIDE		;
	DEC	R0
	JNE	WL11
	MOV	R0,R1
	RET

;
; WRITE THE LOGICAL BLOCK ADDRESS TO THE DRIVE'S REGISTERS
; ORGANISED AS:
; LBA	WORD	0,0
;
; LBA + 3 = HEAD   (MSB)
; LBA + 2 = CYL MSB
; LBA + 1 = CYL LSB
; LBA + 0 = SECTOR (LSB )
;
; R5 HOLDS THE LSB OF THE LBA,  MSB WILL BE ZEROED FOR TIME BEING
;
IDE_WR_LBA:	CLR	@LBA
	MOV	R5,@LBA + 2
	MOVB	@LBA+0,R1		;GET THE FIRST MSB BYTE
	ANDI	R1,0FH*256
	ORI	R1,0E0H*256		; 0EH IS JUST THE 1110 CODE FOR HEAD REGISTER
	LI	PORT,IDE_HEAD		; IDE HEAD
	LDCR	R1,BYTEWIDE
;
	MOVB	@LBA+1,R1
	LI	PORT,IDE_CYL_MSB	;CYLINDER MSB
	LDCR	R1,BYTEWIDE

	MOVB	@LBA+2,R1
	LI	PORT,IDE_CYL_LSB	;CYLINDER LSB
	LDCR	R1,BYTEWIDE

	MOVB	@LBA+3,R1
	LI	PORT,IDE_SECTOR		;CYLINDER LSB
	LDCR	R1,BYTEWIDE
;
; WE NEED TO READ TWO SECTORS TO GET 512 BYTES DUE TO THE FACT THAT WE CAN'T DO 16 BIT READS/WRITES
; SO TWO LBAS REPRESENT A VIRTUAL SECTOR OF 512
;
	LI	R1,2*256		;
	LI	PORT,IDE_SEC_CNT		;CYLINDER LSB
	LDCR	R1,BYTEWIDE

	RET


;======================= END IDE INTERFACE ROUTINES ==============
;

;
;********************************
;
;INTIALISE	INT.VECTORS	ETC
;
;*******************************
;
INTSYS	RET
;
;********************************
;
;RESET	FDC
;
;********************************
;
RSET	RET
;
;
;*******************************************
;
; 	SET THE TIME OUT TIMER
;
SETTIMER:	WORD	INTWP4,SETTIMER+4
	LI	PORT,0080H
	SBZ	20		;RESET INTERRUPT
	LI	R8,200		; 200 X 16MS = 7.0SEC
	MOV	R8,@TIMEOUT
	SBZ	14
	SBO	13		;LOAD INTERVAL TIMER ONLY
	LDCR	@INTLV2,8
	SBO	20		;ENABLE INTERRUPT
	RTWP
;
INTLV2:	BYTE	255		;16.0 MILLISECONDS
	EVEN
;
;;*******************************************
;
;	SEEK TO THE TRACK NUMBER HELD IN R3
;
;	DRIVE # IS IN DRIVE
;
;********************************************
;
SEEK:	CALL	@IDE_READY
	RET
;
;******************************
;
;	MAIN INTERRUPT ROUTINES
;
;********************************
;
FDC_DRQ 	;LI	R0,3		;SHOW WHERE THE INTERRUPT CAME FROM
	;WHEX	R0
	LI	PORT,STSREG
	STCR	R8		;READ THE PORT AND CLEAR THE INTERRUPT
	RTWP
;
;***********************************
;
;	THIS INTERRUPT SIMULATES DMA CONTROL
;	ORGANISED AS FOLLOWS:
;
;	R9 HOLDS CURRENT COMMAND I.E. STCR OR LDCR
;	R8 HOLDS THE CURRENT DMA ADDRESS.
; 	R12 HOLDS THE CURRENT IO PORT - GENERALLY DATREG
;
FDC_RWINT	;LI	R0,2		;SHOW WHERE THE INTERRUPT CAME FROM
	;WHEX	R0
	;X	R9		;EXECUTE THE COMMAND SPECIFIED BY RDWRT
	RTWP
;
;*********************************************************************
;
;	THIS INTERRUPT IS CONTROLED BY THE TIMER ON THE TMS9902
;
;**********************************************************************
;

INTTIMER:	LI	PORT,CRUBASE
	TB	25
	JNE	TIME2
	SBO	20		;RESET INTERRUPT
	DEC	@TIMEOUT
	JNE	TIME2
	INC	@TIMEOUT
	SBZ	20		;DISABLE TIMER
	LI	PORT,SELMUX
	CLR	R8
	LDCR	R8,5		;CLEAR DISKS
TIME2	RTWP
;
;***********************************************************************
;
;	MESSAGES
;
;************************************************************************
;
ERRMSG	BYTE	0DH,0AH,20H
	TEXT	'FDC error type: '
	BYTE	0
;STKMSG	BYTE	0DH,0AH,20H
;	TEXT	'Stack overflow at: '
;	BYTE	0
DRVMSG	TEXT	' Drive: '
	BYTE	0
TRKMSG	TEXT	' Track: '
	BYTE	0
SECTMSG	TEXT	' Sector: '
	BYTE	0
;
;***************************************************************************
;
;	ALL XOP's AND WORKSPACES ARE DEFINED IN THIS SECTION AND ARE USED BY ALL PROGRAMMES
;	THAT INTERACT WITH THE MONITOR ROUTINES
;
;	NOTES.
;		1. ALL INTWP'S AND XOPWP'S OVERLAP AND SO ANY INT OR XOP
;	      	   FUNCTION CODE MAY ONLY USE REGISTERS R8-R10. REGISTERS R11
;	      	   TO R15 ARE RESERVED FOR XOP & INT LINKAGES.
;
;		2. THE XOP WORKSPACES ARE JUST FOR MANAGING THE STACK AND CONTEXT
;		   CALLS THE ORIGINAL WP IS PRESERVED AFTER THE CALL, WHICH MEANS
;		   THAT CALLING ROUTINES SHARE THE SAME REGISTERS.
;
;		3. EVEN THOUGH R9 & R10 ARE GENERALLY USED AS STACK REGISTERS
;		   THIS DOES NOT APPLY IN INTERRUPT WORKSPACE WHERE THEY CAN'T
;		   BE USED FOR THAT PURPOSE - SIMPLY BECAUSE THE STACK POINTER
;		   IS NOT PASSED TO THE NEW WORKSPACE.  THEY CAN BE COPIED USING
;		   THE R13 INDEX IF NEEDED AS R13 POINTS TO THE CALLING ROUTINE'S WORKSPACE
;
;*****************************************************************************
;
;	EVEN
INTWP0	EQU	INTWP		;INTERRUPT WORKSPACE
INTWP1	EQU	INTWP0+16		;ONLY 7 ALLOWED
INTWP2	EQU	INTWP1+16
INTWP3	EQU	INTWP2+16
INTWP4	EQU	INTWP3+16
INTWP5	EQU	INTWP4+16
INTWP6	EQU	INTWP5+16
INTWP7	EQU	INTWP6+16
;
;    NOW XOP'S
;
XOPWP0	EQU	XOPWP
XOPWP1	EQU	XOPWP0+16
XOPWP2	EQU	XOPWP1+16
XOPWP3	EQU	XOPWP2+16
XOPWP4	EQU	XOPWP3+16
XOPWP5	EQU	XOPWP4+16
XOPWP6	EQU	XOPWP5+16
XOPWP7	EQU	XOPWP6+16
XOPWP8	EQU	XOPWP7+16
XOPWP9	EQU	XOPWP8+16
XOPWP10	EQU	XOPWP9+16
XOPWP11	EQU	XOPWP10+16
XOPWP12	EQU	XOPWP11+16
XOPWP13	EQU	XOPWP12+16
XOPWP14	EQU	XOPWP13+16
XOPWP15	EQU	XOPWP14+16
XOPWP16	EQU	XOPWP15+16
;
;	AORG	XOPWP15+32
;
;
;	DEFINE ALL THE XOP ROUTINES
;
;================================================
;
;	XOP0:PSEL
;	TOGGLE PSEL 0 OFF, 1 ON (HIGH, LOW)
;	CALLING METHOD:  PSEL OFF, PSEL ON (LOW, HIGH)
;
;
;================================================
XOP0:	RTWP			;DO NOTHING NOW
;XOP0:	MOV	*R11,R8		;TURN ON?
;	JEQ	XOP01		;NO, TURN OFF
;	ORI	R15,0080H		;YES, TURN IT ON
;	RTWP			;YES
;XOP01	ANDI	R15,0FF7FH		;TURN IT OFF
;	RTWP
;
;============================================
;	SUBROUTINE LONG RETURN
;	CALLING METHOD:	RETF
;
;	STACK ORDER
;	SEGMENT REGISTER (16 bits, Upper 8 bits Called Page, Lower 8 bits return page)
;	INSTRUCTION POINTER
;============================================
;
XOP1:	MOV	@2*SP(R13),SP		;GET STACK POINTER
	MOV	*SP+,R9		;GET SEGMENT REGISTER
	MOV	*SP+,R14		;MOVE IP/PC INTO R14 FOR CALL
	MOV	SP,@2*SP(R13)		;GET UPDATED STACK POINTER
;
; RESTORE CALLING PAGE
;
	MOV	R9,@2*R9(R13)		;RESTORE SEGMENT REGISTER
	MOV	R9,R8
	SWPB	R8		; GET CALLING PAGE
	SLA	R8,7
	LI	PORT,MEMBASE
	LDCR	R8,BYTEWIDE		;GET PAGE VALUE FROM STEP ABOVE
	MOVB	R8,R8		;IS THIS PAGE 0?
	JEQ	XOP1A;		;YES
	ORI	R15,0080H		;YES, SET PSEL BIT
	RTWP
XOP1A	ANDI	R15,0FF7FH		;YES, CLEAR PSEL BIT
	RTWP			;RETURN
;
;======================================================================
;
;   XOP2: SETPAGE - SELECT A NEW BANK OR NEW PAGE USING THE SEGMENT REGISTER R9
;   FOR THIS NEW VERSION TO WORK, THERE MUST BE COMMON MEMORY (6116 SRAM DEFINED)
;
;   PAGE VALUE ON SBC IS D0,D1,D2 AND D3 WHERE D0 IS MSB SO WE NEED TO SHIFT
;   LOWER 4 BITS IN TO THE TOP NYBLLE
;
;   NOTE, THIS ROUTINE DOES NOT SELECT A NEW MEMORY SEGMENT IT JUST SIMILAR
;   TO A MEMORY MAP REGISTER.  IT IS SET BUT ONLY ACTIVE ONCE THE PSEL BIT
;   IN THE STATUS REGISTER IS SET.  THIS IS HOW A MEMORY MAPPER WORKS.
;
;   R9 IS THE SEGMENT REGISTER.  HIGH BYTE IS SEGMENT REGISTER,
;   LOW BYTE IS THE RETURN SEGMENT USED BY FAR_CALLS AND RETF
;
;
;=======================================================================
;
XOP2:	MOVB	@2*R9(R13),R8
	SLA	R8,7		;SHIFT INTO MSB
	LI	PORT,MEMBASE
	LDCR	R8,BYTEWIDE		;GET PAGE VALUE FROM STEP ABOVE
	RTWP
;
;***********************************************
; LONG CALL XOP.
;
;  XOPWP3 IS THE WORKSPACE WE NEED TO OPERATE WITHIN WHICH IS IN PAGED MEMORY NOT COMMON
;
;  CALLING:	LI   R9, MEMORY SEGMENT
;  	LONG_CALL FUNCTION1, FAR_CALL
;
; R13 SAVE WP REGISTER
; R14 SAVED PC REGISTER
; R15 SAVE ST REGISTER
;
; STEPS:
; PUSH PC (IP)  ONTO STACK
; PUSH CODE SEGMENT ONTO STACK ( 0xCCRRH CC:PAGE, RR:RETURN PAGE )
; SET RTWP REGISTERS
; SET NEWPAGE
; SET PSEL BIT IN STATUS REGISTER TO 1
; RTWP TO NEW PROCEDURE/ROUTINE
;
;************************************************
;
XOP3:	MOV	@2*SP(R13),SP 		;GET STACK POINTER FROM CALLING WP IN R13
	DECT	SP
	MOV	R14,*SP		;PUSH SAVED PC ONTO STACK
	DECT	SP
	MOV	SP,@2*SP(R13)		;UPDATE STACK POINTER
	MOV	@2*R9(R13),*SP		;MOVE SEGMENT REGISTER ONTO STACK
	MOV	R11,R14		;MOV EFFECTIVE ADDRESS INTO R14
	MOV	*SP,R8		;GET SEGMENT REGISTER
	SLA	R8,7		;CURRENTLY ONLY TWO PAGES AND D0 IS FROM D7
	LI	PORT,MEMBASE
	LDCR	R8,BYTEWIDE		;GET PAGE VALUE FROM STEP ABOVE
;
; NOW BRING PSEL LOW TO ENABLE MAPPING.
; BY SETTING THE PSEL BIT IN THE STATUS REGISTER
;
;
	MOVB	R8,R8		;IS THIS PAGE 0?
	JEQ	XOP3A;		;YES
	ORI	R15,0080H		;YES, SET PSEL BIT
	RTWP
XOP3A	ANDI	R15,0FF7FH		;YES, CLEAR PSEL BIT
	ORI	R15,0080H		;YES, TURN IT ON
	RTWP			;SWITCH TO NEW MEMORY SEGMENT PRESERVING USER WORKSPACE
;
;
;**********************************************
; PUSH REGISTERS R0 to RN ONTO THE STACK
;*********************************************
;
XOP4	MOV	R13,R8		;GET THE EFFECTIVE ADDRESS OF CALLING WORKSPACE
	MOV	@2*R10(R13),R10	;GET SYSTEM STACK POINTER
XOP4A	DECT	R10		;DECREMENT STACK POINTER
	MOV	*R8+,*R10
	C	R8,R11		;KEEP PUSHING REGISTERS (R11 HOLDS EFFECTIVE ADDRESS OF REGISTER RN)
	JLE	XOP4A
	MOV	R10,@2*R10(R13)	;UPDATE THE STACK POINTER
	RTWP
;
;***********************************************
; POPS REGISTERS R0 to RN OFF THE STACK
;************************************************
;
XOP5	MOV	@2*R10(R13),R10	;GET STACK POINTER
XOP5A	MOV	*R10+,*R11		;GET FIRST REGISTER
	DECT	R11		;DECT TWO EFFECTIVE ADDRESS, IE RN
	C	R11,R13		;COMPARE AGAINST WORKSPACE TOP ADDRESS IE R0
	JHE	XOP5A
	MOV	R10,@2*R10(R13)
	RTWP

;
;************************************************
;	CALL A SUBROUTINE
;	CALLING METHOD:   CALL SUBROUTINE_ADDRESS
;*************************************************
;
XOP6	MOV	@2*SP(R13),SP 	;GET STACK POINTER FROM CALLING WP IN R13
	DECT	SP
;	C	R10,@2*R9(R13)	;CHECK FOR STACK OVERFLOW
;	JLE	STACKERR		;O/P STACK OVERFLOW MESSAGE
	MOV	R14,*SP		;PUSH SAVED PC ONTO STACK
;	ANDI	R14,1		;CHECK FOR ODD
;	JNE    	ODDMSG
	MOV	R11,R14		;MOVE EA INTO R14 FOR CALL
	MOV	SP,@2*SP(R13)	;UPDATE STACK POINTER
	RTWP

;
;============================================
;	SUBROUTINE RETURN
;	CALLING METHOD:	RET
;============================================
;
XOP7	MOV	@2*SP(R13),SP	;GET STACK POINTER
	MOV	*SP+,R14		;MOVE EA INTO R14 FOR CALL
	MOV	SP,@2*SP(R13)	;GET UPDATED STACK POINTER
	RTWP			;RETURN
;
;*************************************************
;	PUSH DATA/REGISTER ONTO THE STACK
;	USES CALLER'S WP AND STACK POINTERS
;*************************************************
;
XOP8	;MOV	@FREEMEM,@2*R9(R13)	;UPDATE FREE MEMORY POINTER IE STACK LIMIT
	MOV	@2*R10(R13),R10
	DECT	R10
;	C	R10,@2*R9(R13)	;CHECK FOR OVERFLOW
;	JLE	STACKERR
	MOV	*R11,*R10		;MOVE DATA FROM EFFECTIVE ADDRESS
	MOV	R10,@2*R10(R13)
	RTWP
;
;	POP DATA/REGISTER OFF STACK
;
XOP9	MOV	@2*R10(R13),R10
	MOV	*R10+,*R11
	MOV	R10,@2*R10(R13)
	RTWP
;
;=====================================================
;	WRITE A HEX CHARACTER
;
;	CALLING METHOD:   WHEX Reg
;
;	FUNCTION: WRITE CONTENTS OF Reg AS 4 HEX DIGITS
;========================================================
;
XOP10	MOV	*R11,R12		;GET VALUE
	LI 	R9,4		;SET COUNTER TO 4 DIGITS
;
XOP10A	MOV	R12,R8		;MOVE 4 DIGITS INTO R8R
	SRL	R8,12		;ISOLATE HEX DIGIT
	SLA	R8,8		;BYTE ALIGN1
	CI	R8,0900H		;IS THIS NUMERIC
	JLE	XOP10B		;YES
	AI	R8,0700H		;ALPHA ADJUST
;
XOP10B	AI	R8,'0'*256		;NUMERIC TO ASCII
	WRITE	R8		;O/P THE HEX DIGIT
	SRC	R12,12		;ALIGN NEXT DIGIT
	DEC	R9		;IF FINISHED EXIT
	JNE	XOP10A
	RTWP
;
;===========================================================
;	READ IN A 16 BIT HEX CHARACTER
;
;	CALL:   RHEX RN
;
;	FUNCTION: READ  CONTENTS INTO  RN AS 4 HEX DIGITS
;============================================================
;
XOP11	CLR	R12		;CLEAR ACCUMULATOR
XOP11A	READ	R10		;GET AN INPUT CHARACTER
	WRITE	R10		;ECHO THE CHARACTER
;
;	CHECK FOR VALID HEX INPUT
;
XOP11B	CI	R10,'0'*256		;BELOW MIN NUMERIC ?
	JL	NOTHEX		;IF YES, JUMP
	CI	R10,'9'*256		;ABOVE MAX NUMERIC ?
	JLE	GOTONE		;IF NO, JUMP
	CI	R10,'A'*256		;BELOW MIN ALPHA ?
	JL	NOTHEX		;IF YES JUMP
	CI	R10,'F'*256		;ABOVE MAX ALPHA ?
	JH	NOTHEX		;IF YES, JUMP
	AI	R10,0900H		;ALPHA ADJUST
GOTONE	SLA	R10,4		;ISOLATE DIGIT
	SRL	R10,12		;WORD ALIGN DIGIT
;
;
; DIGIT TO ACCUMULATOR
;
	SLA	R12,4		;MAKE ROOM FOR NEW DIGIT
	A	R10,R12		;ADD NEW DIGIT IN
	JMP	XOP11A		;GO GET NEXT DIGIT
NOTHEX	MOV	R12,*R11		;RETURN THE VALUE
	RTWP
;
;==================================================
;	WRITE A CHARACTER
;==================================================
;
XOP12	LI	R12,CRUBASE
	SBO	16
XOP12A	TB	22
	JNE	XOP12A
	LDCR	*R11,8
	SBZ	16
	RTWP
;
;====================================================
;	READ CHARACTER INTO LEFT BYTE (MSB)
;====================================================
;
XOP13	LI	R12,CRUBASE
XOP13A	TB	21		;RECEIVE BUFFER REG FULL ?
	JNE	XOP13A		;NO
	CLR	*R11
	STCR	*R11,8
	SBZ	18		;SHOW WE RECEIVED CHARACTER
	RTWP
;
;=========================================================
;
;	OUTPUT A NULL TERMINATED STRING
;	MESG ADDR
;
;==========================================================
;
XOP14	MOVB	*R11+,R12		;GET THE CHARACTER
	JEQ	XOP14A		;IF ZERO EXAT
	WRITE	R12
	JMP	XOP14		;RETURN
XOP14A	RTWP

;=================================================

;
;
;************************************************
;	DEBUG AND TRACING INFORMATION
;
;	DEBUG @MODULE_NAME
;
;	THE MODULE_ID WILL BE PRINTED SO THAT THE USER CAN TELL WHICH
;	MODULE IS BEING DEBUGGED.  KEEP TO 8 BYTES AND NULL TERMINATED
;
;
;*************************************************
;
XOP15:	LI	R8,10		;KEEP NAMES TO 8 BYTES
	LI	R9,DEBUG_NAME
XOP15_NAME:	MOVB	*R11+,*R9+		;SAVE THE NAME
	JEQ	XOP15_MAIN
	DEC	R8
	JNE	XOP15_NAME
	LI	R8,0;		;NULL TERMINATE
	MOVB	R8,*R9

;
; 	NOW SAVE THE TRACE DATA
;
XOP15_MAIN:	LI	R11, DEBUG_BUFFER
	MOV	R14,*R11+		;STORE NEXT STATEMENT PROGRAMME COUNTER
	MOV	R13,*R11+		;STORE WP
	MOV	R15,*R11+		;STORE STATUS
	LI	R8,16		;16 REGISTERS
XOP15_REGS:
	MOV 	*R13+,*R11+		;COPY REGISTERS
	DEC	R8
	JNE	XOP15_REGS
	AI	R13,-32		;RESTOR WORKSPACE REGISTER LOCATION
	JMP	LIST_REG
;
;
; PRINT OUT DEBUGGING/TRACE PC, STATUS AND REGISTERS
;
LIST_REG:	LI	R9,DEBUG_BUFFER
	LI	R8,16
 	MESG	@CRLF		;PRINT INDENTATION
 	MESG	@DEBUG_NAME		;PRINT THE NAME OF THE MODULE
 	MESG	@SP_REG
 	MOV	@2*SP(R13),R10	;GET STACK POINTER
 	WHEX	*R10		;PRINT CONTENTS
	MESG	@PC_REG		;PRINT " PC="
	WHEX	*R9+
	MESG	@WP_REG		;WORKSPACE POINTER
	WHEX	*R9+
	MESG	@ST_REG		;PRINT " ST="
	MOV	*R9+,R11		;GET STATUS REGISTER VALUE
	WHEX	R11
;	MESG	@EA_REG		;EFFECTUVE ADDRESS POINTER
;	WHEX	*R9+
;
	LI	R10,' '*256		;PRINT SPACE
	WRITE	R10
LIST_REGA:	LI	R10,30H*256		;PRINT 0
	SLA	R11,1
	JOC	LIST_REGB
	WRITE	R10
	JMP	LIST_REGC
LIST_REGB:	AI	R10,1*256		;PRINT 1
	WRITE	R10
LIST_REGC:	DEC	R8
	JNE	LIST_REGA
	CLR	R10
LIST_REG1:	MESG	@CRLF		;PRINT CR,LF
LIST_REG2:	LI	R8,'R'*256
	WRITE	R8		;PRINT "R"
	WRITE	@NUMTAB(R10)	;PRINT REGISTER NO
	WRITE	@NUMTAB+1(R10)	;PRINT REGISTER NO
	LI	R8,'='*256
	WRITE	R8
	WHEX	*R9+		;PRINT REGISTER CONTENTS
	INCT	R10
	CI	R10,20H
	JEQ	LIST_EXIT
	LI	R8,' '*256		;PRINT A SPACE
	WRITE	R8
	CZC	@MASK15,R10
	JEQ	LIST_REG1
	JMP	LIST_REG2
LIST_EXIT:	MESG	@CRLF		;PRINT INDENTATION
	RTWP

WP_REG:	TEXT	' WP = '
	BYTE	0
ST_REG:	TEXT	' ST = '
	BYTE	0
PC_REG:	TEXT	' PC = '
	BYTE	0
SP_REG:	TEXT	' *SP = '
	BYTE	0
EA_REG:	TEXT	' EA = '
	BYTE	0
	EVEN
;NUMTAB:	TEXT	'0 1 2 3 4 5 6 7 8 9 101112131415'
;MASKF:	WORD	00FH
;
;************************************************************
;
;THIS SECTION HOLDS ALL THE TIBUG_MONITOR INSTRUCTION
;	Q (QBOOT), U (HEXLOAD),V (HEXLOAD2),G (GO TO) M(MOVE)
;	F(FIND),O (OUTPUT), W (WORK SPACE),R (PRINT_REGS),
;	P(PRINT),X(XCUTE),L(LOWW),H(SETBP),S(STEP),T(TRACE),
;	/(CHAR),.(INSTANT),O(OPEN)
;
;	ONLY PARTIAL IMPLEMENTATION.  FULL CODE IN TIMON.A99 SOURCE
;*********************************************************
;	BOOT INSTRUCTION
;
QBOOT	B	@BOOT		;BRANCH HERE TO LOAD THE SYSTEM
;
;***********************************************************
;	GO INSTRUCTION G
;
GO:	JNE	MON00A		;JNE ON HEXIN FLAG
	B	*R2
;
;*************************************************************
; INSTRUCTION PRINT OUT REGISTERS
;
PRINT_REGS:	LI	R4,2*R13+INTWP3
	MOV	*R4,R4		;R4:=USER WORKSPACE BY DEFAULT
	MOV	R3,R3		;TEST HEXIN FLAG
	JNE	REGIST0
	MOV	R2,R4
REGIST0 	ANDI	R4,0FFFEH		;MAKE ADDRESS EVEN
	MESG	@MESS03+1		;PRINT INDENTATION
	MESG	@WP_REG		;PRINT "WP="
;	MOV	R4,R2		;PRINT WORKSPACE ADDRESS
	WHEX	R4		;PRINT WORKSPACE ADDRESS
	CLR	R5
;	CLR	R10
REGIST1	MESG	@MESS03+1		;PRINT SPACE, CR,LF
REGIST2	LI	R9,'R'*256
	WRITE	R9		;PRINT "R"
	WRITE	@NUMTAB(R5)		;PRINT REGISTER NO
	WRITE	@NUMTAB+1(R5)	;PRINT REGISTER NO
	MESG	@MESS04
	;	R9,'='*256
	;WRITE	R9		;PRINT REGISTER CONTENTS
	WHEX	*R4+		;BL	@HEXOUT
	LI	R9,' '*256
	WRITE	R9
	INCT	R5
	CI	R5,20H		;HAVE 16 REGISTERS BEEN PRINTED?
	JEQ	MON00A
	CZC	@MASK3,R5		;ODD REGISTER, IF SO CRLF
	JEQ	REGIST1
	JMP	REGIST2
;
;
; INSTRUCTION ' ' OPEN INSTRUCTION.  A '-' DELIMITER OPENS THE PREVIOUS LOCATION
;
OPEN:	JNE	OPEN00		;JNE ON HEXIN FLAG
	MOV	R2,R14
OPEN00	ANDI	R14,0FFFEH		;MAKE ADDRESS EVEN
OPEN01	BL	@PADDRC		;PRINT ADDRESS AND CONTENTS
	BL 	@HEXIN
	JNE	OPEN02		;JNE ON HEXIN FLAG
	MOV	R2,*R14
OPEN02	CI	R1,' '*256 		;LAST CHARACTER=" "?
	JNE	OPEN03
	INCT 	R14
	JMP	OPEN01
OPEN03	CI	R1,'-'*256 		;LAST CHARACTER="-"?
	JNE	MON00A
	DECT	R14
	JMP	OPEN01
MON00A	B	@PROMPT
;
; PRINT ADDRESS IN R14
;
PADDRC	MESG	@MESS03+1		;PRINT INDENTATION
	WHEX	R14		;PRINT ADDRESS
	MESG	@MESS03+6		;PRINT "  "
	WHEX	*R14		;PRINT CONTENTS OF ADDRESS
	;BL	@HEXOUT
	MESG	@MESS03+6		;PRINT "  "
	RT			;RETURN FROM BL
;
; 	INSTRUCTION OUTPUT 'O'
;
OUTPUT:	MOV	R15,R4
	MOV	R3,R3
	JNE	OUTPUT0
	MOV	R2,R4
OUTPUT0 	ANDI	R4,0FFFEH		;MAKE ADDRESS EVEN
	MOV	R4,R5
	ANDI	R5,0FFF0H
	AI	R5,80H
OUTPUT1	MESG	@MESS03+1		;PRINT INDENTATION
;	MOV	R4,R2
;	BL	@HEXOUT0		;PRINT ADDRESS
	WHEX	R4		;PRINT ADDRESS
	MESG	@MESS03+5		;PRINT " "
	;MOV	*R4+,R2
	;BL	@HEXOUT
OUTPUT2 	WHEX	*R4+
	MESG	@MESS03+6		;PRINT " "
	C	R4,R5
	JEQ	OUTPUT3
	CZC	@MASK15,R4
	JEQ	OUTPUT1
	JMP	OUTPUT2
OUTPUT3	READ	R1		;GET CHARACTER
	CI	R1,' '*256
	JNE	MON00A
	AI	R5,80H		;AN EXTRA 4 LINES
	JMP	OUTPUT1
;
; INSTRUCTION W
;
WP:	JNE	WP00		;JNE ON HEXIN FLAG
	MOV	R2,@2*R13+INTWP3
	JMP	MON00A
WP00	MESG	@MESS03			;PRINT INDENTATION
	MESG	@WP_REG			;PRINT "WP="
	MOV	@2*R13+INTWP3,R2
	WHEX	R2
	JMP	MON00A

;
;**************************************************************
;	COMMAND LOAD HEX FILE
;
;	ALGORITHM TAKEN FROM DDJ #22
;
;	R3  HOLDS CHECKSUM
;	R4  HOLDS RECORD LENGTH
;	R5  HOLDS LOAD ADDRESS
;
;***************************************************************
;
HEXLOAD:	LI	R2,':'*256
	READ	R1		;SEARCH FOR ':'
	CB	R1,R2		;COMPARE BYTE FOR :
	JNE	HEXLOAD
	WRITE	@DOT		;DEBUG INFO
	CLR 	R3		;CLEAR CHECKSUM
	CALL	@NEXTBYTE		;GET RECORD LENGTH
	MOVB	R1,R4
	SRL	R4,8		;LENGTH IN R4
	JEQ	INST_EXIT		;WERE DONE
	CALL	@NEXTADDR		;GET LOAD ADDRESS
	MOV	R1,R5
	CALL	@NEXTBYTE		;GET RECORD TYPE
HL_12	MOV	R4,R4		;IF RL=0 GO TO A13
	JEQ	HL_13
	CALL	@NEXTBYTE
	MOVB	R1,*R5+		;STORE DATA IN MEMORY
	DEC	R4		;REDUCE RECORD LENGTH
	JMP	HL_12
HL_13	CALL	@NEXTBYTE		;GET CHECKSUM BYTE
;	MOVB	R3,R3		;CHECK FOR ZERO
	JEQ	HEXLOAD
;
; FALL THROUGH TO ERROR
;
HL_14	READ	R1		;READ ANY RUBBISH
	WRITE	@LOADERR		;TELL TERMINAL SYSTEM TO STOP
	READ	R1		;READ ANY RUBBISH
INST_EXIT:	B	@PROMPT		;BACK TO TIMON
;
;
;**************************************************************
;	COMMAND LOAD HEX FILE 2
;	SEMENTED MEMORY PAGES VERSION (V)
;	ADDRESS FORMAT SINGLE BYTE PAGE NUMBER THEN 00 16BIT ADDRESS
;
;	ALGORITHM TAKEN FROM DDJ #22
;
;	R3  HOLDS CHECKSUM
;	R4  HOLDS RECORD LENGTH
;	R5  HOLDS LOAD ADDRESS
;
;***************************************************************
;
HEXLOAD2:	LI	R2,':'*256
	READ	R1		;SEARCH FOR ':'
	CB	R1,R2		;COMPARE BYTE FOR :
	JNE	HEXLOAD2
	WRITE	@DOT		;DEBUG INFO
	CLR 	R3		;CLEAR CHECKSUM
	CALL	@NEXTBYTE		;GET RECORD LENGTH
	MOVB	R1,R4
	SRL	R4,8		;LENGTH IN R4
	JEQ	INST_EXIT		;WERE DONE
	CALL	@NEXTBYTE		;GET PAGE.BYTE.
;	MOVB	R1,R1		;IF ZERO CONTINUE
;	JEQ	HL_21
;
;	SWITCH PAGE
;
	WRITE	@PLUS
	NEWPAGE	R1		;SWITCH TO NEW PAGE

HL_21	CALL	@NEXTADDR		;GET LOAD ADDRESS
	MOV	R1,R5
	CALL	@NEXTBYTE		;GET RECORD TYPE
HL_22	MOV	R4,R4		;IF RL=0 GO TO A13
	JEQ	HL_23
	CALL	@NEXTBYTE
	MOVB	R1,*R5+		;STORE DATA IN MEMORY
	DEC	R4		;REDUCE RECORD LENGTH
	JMP	HL_22
HL_23	CALL	@NEXTBYTE		;GET CHECKSUM BYTE
;	MOVB	R3,R3		;CHECK FOR ZERO
	JEQ	HEXLOAD2
	JMP	HL_14

NEXTBYTE:	CLR 	R2		;ACCUMULATOR
	READ	R1
	CALL	@CATOH		;CONVERT ASCII TO HEX
	MOVB	R1,R2
	SLA	R2,4		;MOVE IT OVER
	READ	R1		;NEXT ASCII CHAR
	CALL	@CATOH
	SOCB	R1,R2		;BYTE NOW IN R1
	MOV	R2,R1
	AB	R1,R3		;UPDATE CHECKSUM
	RET
;
NEXTADDR:	CALL	@NEXTBYTE
	MOV	R1,R5
	CALL	@NEXTBYTE
	SWPB	R1
	SOC	R5,R1
	RET
;
;	ASCII TO HEX CONVERTER
;
CATOH:	CI	R1,'9'*256
	JLE	CATOH_1
	AI	R1,0900H		;ALPHA ADJUST
CATOH_1	ANDI	R1,0F00H
	RET
;
;---INITIALISE TMS9902 FOR BAUD RATE OF 19200:
;   PROTOCOL SETTINGS
; 	*BAUD RATE
;	*8 BITS/CHARACTER
;	*NO PARITY
;	*2 STOP BITS
;
CRUBASE: 	EQU	0080H
INITIAL:	RSET			;RSET
	LWPI	WORKSP		;USE MONITOR LOCAL WORKSPACE
	CLR	R15		;CLEAR STATUS AND MAKE SURE BIT 8 IS ZERO
;	LST	R15
	LI	SP,STACKP		;STACK FOR LOCAL MONITOR USE
;
;DISABLE ALL INTERRUPTS WHILE INITALISING
;
	LI	R12,CRUBASE
	SBO	31		;RESET TMS9902
	LDCR	@CTL02,8
	SBZ	13		;DO NOT SET INTERVAL REGISTER
	CLR	R3		;RESET LOOP COUNT
TSTSP	TB	15		;SPACE
	JEQ	TSTSP		;NO JUMP BACK
SPLOOP	INC	R3		;TIME THE START BIT
	TB	15		;FALL OUT ON MARK
	JNE	SPLOOP
;
;---TABLE SEARCH FOR BAUD RATES
;	SET AT 19200 or BD57600
;
;	LI	R7,BD19200		;SET POINTER TO TABLE
	LI	R7,BD57600		;SET POINTER TO TABLE
	INCT	R7		;POINT TO THE NEXT WORD THAT HOLDS THE TMS9902 CODES
;400	JMP	BDMATCH		;FORCE THE BAUD RATE TO BE 19200
;
; LOAD THE BAUD RATE VALUES
;

BDMATCH	LDCR	*R7,12 		;INT RECV/TXMT DATA RATE
	LDCR	*R7,11
	STCR	R7,8		;PULL OUT ANY JUNK
	STCR	R7,8
;
; CLEAR PAGE ADDESSES AND REVERT TO PAGE 0
;
	CLR	R9		;CLEAR SEGEMENT AND SELECT PAGE 0
	LI	PORT,MEMBASE
	LDCR	R9,BYTEWIDE		;GET PAGE VALUE FROM STEP ABOVE
;
; NOW ENTER THE TIBUG_MONITOR COMMANDS
;
;
	BL	@INIT_VECTORS		;INITIALISE ALL XOP AND INTERRUPT VECTORS
	B	@BANNER
;
CTL02	BYTE	43H		;43H FOR A 3 MHZ CLOCK 4B FOR A 4 MHZ CLOCK
	EVEN
BD57600	WORD	2,9H 		;BAUD RATE = 57600
BD19200 	WORD	9,1AH		;BAUD RATE = 19200
;BD9600	WORD 	19,34H		;BAUD RATE = 9600
;

;CLRRECV:	LI	R12,CRUBASE
;	STCR	R0,8		;CLEAR INPUT
;	SBZ	18		;SHOW WE RECEIVED CHARACTER
;	RET
;
;---Place load vectors into FFFC & FFFE
;
	AORG	0FFFCH
	WORD	WORKSP
	WORD	INITIAL
;
	END


