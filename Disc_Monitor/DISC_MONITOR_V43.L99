                        ;
                        ;-----------------------------------------------------------------------
                        ;	MONITOR AND FDC INTERFACE ROUTINES for the TI99000 SBC
                        ;
                        ;	 Written by Alex Cameron
                        ;
                        ;	The monitor routines are called from a DOS or other
                        ;	programme to perform Console I/O and Disc I/O similar
                        ;	to a BIOS.
                        ;
                        ;	Version 2.1	14th May 2020 - The year of the Corona Virus
                        ;	Version 2.2	3rd February, 2024 -
                        ;		Combined partial set of TIBUG commands into Monitor
                        ;		and targeted for the SBC ROM.
                        ;		RAM ADDRESS: EC00H-EFFFH;
                        ;		ROM ADDRESS: F000H-FFFFH
                        ;	VERSION 3.0	9th June, 2024
                        ;		Support added to allows for a IDE/SATA interface using LBA sectors.
                        ;	VERSION 4.1	29th July, 2024
                        ;		Support segmented memory model and removal of Floppy Disc Code
                        ;	VERSION 4.21	7th September, 2024
                        ;		Support segmented memory model extension of a PSEL SET AND CLEAR
                        ;
                        ;---------------------------------------------------------------------
                        ;
  0000                  R0	EQU	0
  0001                  R1	EQU	1
  0002                  R2	EQU	2
  0003                  R3	EQU	3
  0004                  R4	EQU	4
  0005                  R5	EQU	5
  0006                  R6	EQU	6
  0007                  R7	EQU	7
  0008                  R8	EQU	8
  0009                  R9	EQU	9		;Use to index workspace pointer not stack overflow
                        ;SL	EQU	R9		;STACK LIMIT
  000A                  R10	EQU	10
  000A                  SP	EQU	R10		;STACK POINTER
  000B                  R11	EQU	11
  000C                  R12	EQU	12
  000C                  PORT	EQU	R12		;IO BASE
  000D                  R13	EQU	13
  000E                  R14	EQU	14
  000F                  R15	EQU	15
  000F                  ST	EQU	15
                        ;
                        ;***************************************************
                        ;
                        ;	DEFINE SOME XOP'S.
                        ;	ALL PROGRAMMES USE THESE XOPS
                        ;
                        ;****************************************************
                        ;
                        	DXOP	BDOS,0
                        	DXOP	RETF,1
                        	DXOP	SETPAGE,2		;SET PAGE/SEGMENT REGISTER
                        	DXOP	SWBANK,3
                        	DXOP	PUSHREG,4		;PUSH RANGE OF REGISTERS TO STACH
                        	DXOP	POPREG,5
                        	DXOP	CALL,6
                        	DXOP	RET,7
                        	DXOP	PUSH,8		;PUSH SINGLE REGISTER
                        	DXOP	POP,9
                        	DXOP	WHEX,10		;WRITE OUT A 16 BIT HEX VALUE
                        	DXOP	RHEX,11		;READ IN A 16 BIT HEX VALUE
                        	DXOP	WRITE,12		;WRITE CHAR IN MSB
                        	DXOP	READ,13		;READ CHAR IN MSB
                        	DXOP	MESG,14		;OUTPUT NULL TERMINATED MESSAGE
                        	DXOP	DEBUG,15		;DEBUG CURRENT LOCATION & STORE INTO DEBUG_BUFFER
                        ;
                        ; SOME EQUATES.  NOTE WORKSP MUST BE IN COMMON MEMORY
                        ;
  F000                  MONORG:	EQU	0F000H		;ORIGIN FOR THIS MONITOR
  0000                  INTVEC:	EQU	0000H		;START AT THE TOP
  0040                  XOPVEC:	EQU	0040H
  00B0                  INTWP:	EQU	00B0H		;;7 INT AND 16 XOPS WORKSPACES OF 16 BYTES EACH
  0130                  XOPWP:	EQU	0130H		;XOP WORKSPACE ALLOCATION FOR ALL XOPS
  0230                  WORKSP:	EQU	0230H		;USE AREA BELOW XOP WORKSPACES - 32 BYTES
  0500                  STACKP:	EQU	0500H		;COMMON STACK USED BY ALL PROGRAMMES
  0088                  MON_PTR:	EQU	0088H		;MONITOR VECTOR.  PROGRAMMES CAN USE THIS
  0500                  TPA:	EQU	0500H		;PROGRAME LOAD AREA
                        ;
                        ; THIS IS WHERE THE LBA (TWO WORDS) ARE STORED SO IT CAN BE LOADED
                        ;
  00A8                  LBA:	EQU	0A8H		;TWO WORDS (4 BYTES)
  0086                  BDOSV:	EQU	086H		;VECTOR SUPPLIED BY SHELL.  SHELL AND BDOS MUST BE LOADED BEFORE CALLING THIS
                        
                        ;
                        ; DECLARE VARIABLES THAT NEED RAM
                        ;
  ED00                  BUFFER:	EQU	MONORG-0300H		;THIS IS A TEMPORARY BUFFER USED BY BOOT
  EF00                  LOCAL_RAM: 	EQU	MONORG-0100H
  EF00                  	AORG	LOCAL_RAM
  EF00                  	BSS	32
                        ;
                        ;	NOTE THIS IS USED BY DEBUG TO STORE MULTIPLE DEBUG POINTERS TO
                        ;	PROGRAMMES CALLING DEBUG
                        ;
  EF20                  DEBUG_NAME:	BSS	10		;;NAME OF MODULE 8 CHARS LONG NULL TERMINATED
  EF2A                  DEBUG_BUFFER:	BSS	20		;DEBUG TRACE LIST
                        
                        ;
                        ;-- RAM BASED IO PARAMETER BLOCK - NOT USED WITH IDE
                        ;
  EF3E                  	EVEN
  EF3E                  DISC_PARAM:	EQU	$ + 0
  EF3E   0000           FDCSTATUS:	WORD	0	 	;OPERATION STATUS
  EF40   0001           TIMEOUT:	WORD 	1		;N * 16MS DURATION
  EF42   0000           DISC_INUSE:	WORD	0
                        
  0006                  RAM_SIZE:	EQU	$ - DISC_PARAM
                        
                        ;	AORG	0400H
                        ;	SETO	R9		;CLEAR SEGEMENT AND SELECT PAGE 0
                        ;	LI	PORT,MEMBASE
                        ;	LDCR	R9,BYTEWIDE		;GET PAGE VALUE FROM STEP ABOVE
                        ;	BLWP	@INIT_MONITOR
                        ;
                        ;;-----TESTING CODE
                        ;	AORG	0500H
                        ;	BLWP	@TEMP
                        ;TEMP:	WORD	WORKSP
                        ;	WORD	INITIAL
                        
                        
                        ;----- END TESTING CODE
                        ;
                        ; LOCATE THE MONITOR IN MEMORY
                        ;
  F000                  	AORG	MONORG
                        ;
                        ; INITIALISATION
                        ;
                        ;
                        ;************************************************************************************
                        ;
                        ;	USE BLWP @MONITOR TO INITIALISE MONITOR VECTORS AND INTERRUPTS
                        ;
                        ;	NOTE ALL PROGRAMMES OR MODULES MUST SET THEIR WORSPACE
                        ;	POINTERS AND STACKS BEFORE CALLING, e.g.
                        ;
                        ;	AORG 0100H
                        ;	LWPI WORKSP
                        ;	BLWP @INIT_MONITOR
                        ;	<INITIALISED MONITOR WILL RETURN HERE>
                        ;
                        ;
                        ;*************************************************************************************
                        ;
                        INIT_MONITOR:
  F000   0230           	WORD	WORKSP		;THIS IS MONITOR WORKSAPCE
  F002   F828           	WORD	INITIAL		;INITIALISE ALL XOP, INTERRUPT AND ENTRY VECTORS
  F004   0460 F202      BOOT_ADDR:	B	@BOOT		;PERFORM A COLD BOOT - POS IN TABLE HELPS DEBUGGING
  F008   0460 F26A      	B	@CIN		;CHAR IN
  F00C   0460 F26E      	B	@COUT		;CHAR OUT
  F010   0460 F276      	B	@SELDSK		;SELECT A DISK DRIVE
  F014   0460 F27A      	B	@RECAL	 	;RECALIBRATE DRIVES
  F018   0460 F3F0      	B	@SEEK		;SEEK THE TRACK IN R3
  F01C   0460 F27E      	B	@RDREC		;READ SELECTED SECTOR
  F020   0460 F286      	B	@WRREC	 	;WRITE SELECTED SECTOR
  F024   0460 F27C      	B	@RDID		;READ TRACK ID ADDRESS
  F028   0460 F200      	B	@WBOOT		;PERFORM A WARM BOOT
  F02C   0460 F282      	B	@RDTRK		;READ A TRACK OF DATA
  F030   0460 F284      	B	@WRTRK		;WRITE A TRACK OF DATA
                        
                        ;
                        ;**********************************************************
                        ;
                        ;	DMA PARAMETER BLOCK DEFINITIONS
                        ;	INDEXED DEPENDING ON READ(0), OR WRITE(1) COMMAND
                        ;
                        ;************************************************************
                        ;
  F034   34B8           CMDTBL:	STCR	*R8+,BYTEWIDE	;BYTE WIDE FDC DATA READ
  F036   30B8           	LDCR	*R8+,BYTEWIDE	;BYTE WIDE FDC DATA WRITE
                        ;
                        ;--REGISTERS IN INTERRUPT 3 WORKSPACE
                        ;
  00E2                  DMACMD	SET	2*R9+INTWP2		;CURRENT COMMAND
  00E0                  DMAADDR 	SET	2*R8+INTWP2		;REGISTER HOLDING SOURCE ADDRESS
  00E8                  DMAPORT	SET	2*R12+INTWP2	;IO BASE REG I.E. DATAREG
                        
  F038   0D0A 00        CRLF	BYTE	0DH,0AH,0
  F03B   00             	EVEN
                        ;
                        ;--FDC 1797 IO REG LOCATIONS.  SET BY ADDRESS BITS A13,A14   HENCE 2, 4 6
                        ;
  8000                  FDC1797:	EQU	8000H		;IO BASE REGISTER- BYTE TRANSFER WITH MSB SET
  8000                  STSREG:	EQU	FDC1797+0 		;MAIN STATUS REG
                        ;CMDREG:	EQU	FDC1797+0 		;COMMAND REGISTER
                        ;TRKREG:	EQU	FDC1797+2		;TRACK REGISTER
                        ;SECREG:	EQU	FDC1797+4		;SECTOR REGISTER
                        ;DATREG:	EQU	FDC1797+6		;DATA REGISTER
                        ;
                        ; BANK SWITCHING PORT
                        ;
  80C0                  MEMBASE:	EQU	80C0H		;BASE MEMORY BANK SWITCH PORT
  0780                  LDS:	EQU	0780H	;        Long Distance Source instruction operand.
  07C0                  LDD:	EQU	07C0H	;        Long Distance Destination instruction operand.
                        
                        ;
                        ;
                        ;--PORTS ETC.
                        ;
  0000                  SELMUX:	EQU	0		;SELECT CONTROL PORT (R12 CRU PORT)
                        ;TYPMUX:	EQU	SELMUX + 2*5	;START AT BIT 5
  0002                  BYTEWIDE:	EQU	2		;PARALLEL I/O DONE IN BYTES (UNIQUE TO 99105)
                        ;
                        ;
                        ; THESE ARE THE TIBUG BASIC COMMANDS, SUCH AS:
                        ; QBOOT, ADDR G(O), ADDR O(UTPUT), W(ORKSPACE), R(EGISTERS), ADDRESS O(PEN).
                        ;
                        ; TIBUG WILL BE THE DEFAULT ENTRY POINT.
                        ; BOOTING IS EFFECTED BY ISSUING THE Q(QBOOT) COMMAND
                        ;
                        ;TIBUG_ENTRY: AND WE CAN NOW ENABLE INTERRUPTS
                        ;
  F03C   0300 0007      BANNER	LIMI	7		;ENABLE INTERRUPTS
  F040   2FA0 F0F2      	MESG	@MESS00		;_PRINT ">> TMS9900 TIBUG <<"
  F044   2FA0 F10F      PROMPT	MESG	@MESS01		;PRINT PROMPTER
  F048   06A0 F122      	BL	@HEXIN		;OBTAIN ADDRESS IN R2 AND INSTRUCTION IN R1
  F04C   0204 0014      	LI	R4,20		;20 POSSIBLE INSTRUCTIONS
  F050   9064 F09A      MON01	CB	@INTAB(R4),R1		;SEARCH INTAB
  F054   1305           	JEQ	MON03
  F056   0604           	DEC	R4
  F058   18FB           	JOC	MON01
  F05A   2FA0 F113      MON02	MESG	@MESS02		;PRINT " ??"
  F05E   10F2           	JMP	PROMPT
  F060   0A14           MON03	SLA	R4,1		;BRANCH TO APPROPRIATEE ROUTINE
  F062   C124 F0B0      	MOV	@SUBTAB(R4),R4	;
  F066   C0C3           	MOV	R3,R3		;TEST HEXIN FLAG
  F068   0454           	B	*R4
                        ;
                        ;  TIBUG INSTRUCTION TABLE
                        ;
  F06A   3031 3233      HEXTAB	TEXT	'0123456789ABCDEF'
  F06E   3435 3637      
  F072   3839 4142      
  F076   4344 4546      
  F07A   3020 3120      NUMTAB	TEXT	'0 1 2 3 4 5 6 7 8 9 101112131415'
  F07E   3220 3320      
  F082   3420 3520      
  F086   3620 3720      
  F08A   3820 3920      
  F08E   3130 3131      
  F092   3132 3133      
  F096   3134 3135      
  F09A   1A             INTAB	BYTE	1AH		;CONTROL Z(CLEARS SCREEN) AND VERSION
  F09B   2F2F 5155      	TEXT	'//QUVGMZOWRPXLHST/. '
  F09F   5647 4D5A      
  F0A3   4F57 5250      
  F0A7   584C 4853      
  F0AB   542F 2E20      
  F0AF   00             	EVEN
  F0B0   F03C 0000      SUBTAB	WORD	BANNER,0,0,QBOOT,HEXLOAD,HEXLOAD2,GO,MOVE,FIND,OUTPUT,WP,PRINT_REGS,PRINT
  F0B4   0000 F678      
  F0B8   F760 F7A4      
  F0BC   F67C F0E6      
  F0C0   F0E8 F708      
  F0C4   F748 F680      
  F0C8   F0F0           
  F0CA   F0EA F0EC      	WORD	XCUTE,LOWW,SETBP,SSTEP,TRACE,CHAR,INSTANT,OPEN
  F0CE   F0E0 F0DE      
  F0D2   F0E2 F0E4      
  F0D6   F0EE F6CA      
                        
                        
                        	;
                        	; COMMANDS IMPLEMENTED IN DISC_MONITOR
                        	; REGIST, OPEN, GO AND QBOOT.
                        	;
                        ;MASK32	WORD	001FH
  F0DA   000F           MASK15	WORD	000FH
                        ;MASK8	WORD	0007H
  F0DC   0003           MASK3	WORD	0003H
                        ;
                        ; DUMMY LIST
                        ;
  F0DE   10B2           SSTEP:	JMP	PROMPT;   NULL COMMAND
  F0E0   10B1           SETBP:	JMP	PROMPT;   NULL COMMAND
  F0E2   10B0           TRACE:	JMP	PROMPT;   NULL COMMAND
  F0E4   10AF           CHAR:	JMP	PROMPT;   NULL COMMAND
  F0E6   10AE           MOVE:	JMP	PROMPT;   NULL COMMAND
  F0E8   10AD           FIND:	JMP	PROMPT;   NULL COMMAND
  F0EA   10AC           XCUTE:	JMP	PROMPT;   NULL COMMAND
  F0EC   10AB           LOWW:	JMP	PROMPT;   NULL COMMAND
  F0EE   10AA           INSTANT:	JMP	PROMPT;   NULL COMMAND
  F0F0   10A9           PRINT:	JMP	PROMPT;   NULL COMMAND
                        ;
                        ;ONLY THESE ONES HAVE BEEN IMPLEMENT WITHIN THE DISC_MONITOR ROM.  AS
                        ;THE ADDRESS SPACE HAS BEEN TAKEN UP WITH THE DISC-IO AND THE OTHER FUNCTIONS
                        ;CAN BE EASILY IMPLEMENTED WITH DISC BASED PROGRAMMES.
                        ;
                        ;QBOOT:	JMP	PROMPT;   NULL COMMAND
                        ;GO:	JMP	PROMPT;   NULL COMMAND
                        ;OUTPUT:	JMP	PROMPT;   NULL COMMAND
                        ;WP:	JMP	PROMPT;   NULL COMMAND
                        ;PRINT_REGS: JMP	PROMPT;   NULL COMMAND
                        ;OPEN:	JMP	PROMPT;   NULL COMMAND
                        ;
                        ; MESSGES AND OTHER EQUATES
                        ;
  F0F2   0D0A           MESS00	BYTE	CR,LF
  F0F4   3C54 4D53      	TEXT	'<TMS9900 DISC MONITOR V4.3>'
  F0F8   3939 3030      
  F0FC   2044 4953      
  F100   4320 4D4F      
  F104   4E49 544F      
  F108   5220 5634      
  F10C   2E33 3E        
                        ;	BYTE	0
  F10F   0D0A           MESS01	BYTE	CR,LF
  F111   3E             	TEXT	'>'
  F112   00             	BYTE	0
  F113   3F3F           MESS02	TEXT	'??'
  F115   00             	BYTE	0
  F116   0A0D 0A        MESS03	BYTE	LF,CR,LF
  F119   2020 2020      	TEXT	'    '
  F11D   00             	BYTE	0
  F11E   203D 20        MESS04	TEXT	' = '
  F121   00             	BYTE	0
                        ;
  000D                  CR:	EQU	0DH		;CARRIAGE RETURN
  000A                  LF:	EQU	0AH		;LINE FEED
  F122                  	EVEN
                        
                        ;
                        ;*********************************
                        ; SUPPORT ROUTINES FOR INPUT AND OUTPUT
                        ;**********************************
                        ;
                        ;
                        ; SUBROUTINE HEXIN
                        ; INPUTS A HEX NO. INTO R2
                        ; AND INSTRUCTION INTO R1
                        ; (INSTRUCTION ' ' INSERT AND MOVE TO NEXT ADDRESS
                        ; (INSTRUCTION '-' INSERT AND MOVE TO PREVIOUS ADDRESS
                        ; THE HEX INDEX USES THE TRANSLATE TABLE HEXTAB TO IDENTIFY THE HEX DIGIT.
                        ; THE LAST CHARACTER, EITHER SPACE OR - BREAKS THE CYCLE AS THEY ARE NOT IN THE HEXTABLE
                        ;
                        ; USES R1,R2,R3,R4
                        ;
  F122   04C1           HEXIN:	CLR	R1
  F124   04C2           	CLR	R2
  F126   0703           	SETO	R3		;SET FLAG
  F128   2F41           HEXIN0	READ	R1		;GET CHARACTER
  F12A   2F01           	WRITE	R1		;PRINT CHARACTER
  F12C   0204 000F      	LI	R4,15
  F130   9064 F06A      HEXIN1	CB	@HEXTAB(R4),R1
  F134   1604           	JNE	HEXIN2
  F136   04C3           	CLR	R3		;CLEARS FLAG
  F138   0A42           	SLA	R2,4		;SHIFTS HEX DIGIT INTO R2
  F13A   E084           	SOC	R4,R2
  F13C   10F5           	JMP	HEXIN0
  F13E   0604           HEXIN2	DEC	R4
  F140   18F7           	JOC	HEXIN1		;SUBTRACTING 1 FROM 0 DOES NOT RESULT IN CARRY
  F142   C0C3           	MOV	R3,R3		;TEST HEXIN FLAG
  F144   045B           	RT			;RETURN FROM BL
                        ;
                        ; SUBROUTINE HEXOUT			;OUTPUT CONTENTS OF R2
                        ; USES R0,R1,R2,R3
                        ;
                        ;HEXOUT	WRITE	@MESS03+7		;PRINTS " "
                        ;HEXOUT0	PUSHREG	R3		;SAVE R0-R3
                        ;HEXOUTX	CLR	R0
                        ;	LI	R3,4
                        ;HEXOUT1	SRC	R2,12
                        ;	MOV	R2,R1
                        ;	ANDI	R1,000FH
                        ;	MOVB	@HEXTAB(R1),R0
                        ;	WRITE	R0
                        ;	DEC	R3
                        ;	JNE	HEXOUT1
                        ;	POPREG	R3		;RESTORE R3-R0
                        ;	RT
                        ;
  F146   2E00           DOT:	BYTE	'.',0
  F148   2B00           PLUS	BYTE	'+',0
  F14A   4C4F 4144      LOADERR:	TEXT	'LOAD ERROR'
  F14E   2045 5252      
  F152   4F52           
  F154   00             	BYTE	0
  F155   00             	EVEN
                        ;
                        ;**********************************************
                        ;  XOP WP ENTRY POINTS
                        ;**********************************************
                        ;
  F156   0130 F450      XOPTAB:	WORD	XOPWP0,XOP0,XOPWP1,XOP1,XOPWP2,XOP2,XOPWP3,XOP3
  F15A   0140 F460      
  F15E   0150 F48C      
  F162   0160 F49A      
  F166   0170 F4C8      	WORD	XOPWP4,XOP4,XOPWP5,XOP5,XOPWP6,XOP6,XOPWP7,XOP7,XOPWP8,XOP8
  F16A   0180 F4DC      
  F16E   0190 F4EE      
  F172   01A0 F4FE      
  F176   01B0 F50A      
  F17A   01C0 F518      	WORD	XOPWP9,XOP9,XOPWP10,XOP10,XOPWP11,XOP11
  F17E   01D0 F524      
  F182   01E0 F548      
  F186   01F0 F578      	WORD	XOPWP12,XOP12,XOPWP13,XOP13,XOPWP14,XOP14,XOPWP15,XOP15
  F18A   0200 F588      
  F18E   0210 F598      
  F192   0220 F5A2      
                        ;
  F196   0230 F828      INTTAB:	WORD	WORKSP,INITIAL,INTWP1,INT1,INTWP2,FDC_RWINT, INTWP3,FDC_DRQ	;FDC1797 INTERUPT VECTORS
  F19A   00C0 F1B6      
  F19E   00D0 F3FE      
  F1A2   00E0 F3F6      
  F1A6   00F0 F400      	WORD	INTWP4,INTTIMER,INTWP5,IDE_IRQ, INTWP6, IDE_DMARQ, INTWP7,INT7 	;TIMER INTERRUPT
  F1AA   0100 F2AE      
  F1AE   0110 F2B6      
  F1B2   0120 F1B8      
                        ;
                        INT1:	;LI	R0,1
                        	;WHEX	R0
  F1B6   0380           	RTWP
                        INT7:	;LI	R0,7
                        	;WHEX	R0
  F1B8   0380           	RTWP
                        ;
                        ;	NOTE.  APPLICATIONS MUST CALL WITH THEIR WP POINTERS SET
                        ;	THIS CALL IS USED TO SET UP MONITOR AND IS CALLED USING BL
                        ;	CALLED USING BLWP @MONITOR
                        ;
  F1BA   0360           INIT_VECTORS:	RSET			;CLEAR INTERRUPT MASK
                        ;	LWPI	WORKSP		;USE MONITOR LOCAL WORKSPACE
                        ;	LI	SP,STACKP		;STACK FOR LOCAL MONITOR USE
                        ;
                        ;	LI	R0,MON_PTR		;SET UP THE MONITOR POINTER
                        ;	LI	R1,MONORG
                        ;	MOV	*R1+,*R0+		;MOVE WORKSPACE POINTER
                        ;	MOV	*R1+,*R0+		;MOVE MONITOR INITIALISATION ADDRESS
                        ;
                        ;************************************************************
                        ;
                        ;	SWTICH TO MONITOR XOP VECTORS RATHER THAN TIMON ROM
                        ;	THIS MEANS THAT ALL PROGRAMMES THAT USE XOP WILL USE THE
                        ;	THE XOP IMPLEMENTATIONS DEFINED IN MONITOR THAT IS HERE!
                        ;
                        ;************************************************************
                        
  F1BC   0200 0000      	LI	R0,INTVEC		;SET UP INTERRUPT VECTORS
  F1C0   0201 F196      	LI	R1,INTTAB		;ONLY INT 0 TO 7
  F1C4   CC31           INIT1:	MOV	*R1+,*R0+
  F1C6   CC31           	MOV	*R1+,*R0+
  F1C8   0280 0020      	CI	R0,INTVEC+8*4		;8 INTERRUPT VECTORS
  F1CC   16FB           	JNE	INIT1
                        ;
                        ;ZERO UNUSED INTERRUPT WORDS AND OTHER INITIALISATION AREAS UP TO TPA
                        ;
  F1CE   0200 00B0      	LI	R0,INTWP0
  F1D2   0201 0500      	LI	R1,TPA
                        INIT2:	;CLR	*R0+
                        	;C	R0,R1
                        	;JNE	INIT2
                        ;
                        ;INITIALISE XOP-START AT XOP0, INTO MEMORY LOCATION AT 40H
                        ;
  F1D6   0200 0040      	LI	R0,XOPVEC
  F1DA   0201 F156      	LI	R1,XOPTAB
  F1DE   CC31           INIT3:	MOV	*R1+,*R0+
  F1E0   CC31           	MOV	*R1+,*R0+
  F1E2   0280 0080      	CI	R0,80H		;FINISHED?
  F1E6   16FB           	JNE	INIT3		;NO
                        ;
                        ;Now initialise DISC and OTHER RAM.  FIRST ZERO THEN COMPY PRESETS
                        ;
  F1E8   0200 0006      	LI	R0,RAM_SIZE
  F1EC   0201 EF3E      	LI	R1,DISC_PARAM
  F1F0   04C2           	CLR	R2
  F1F2   DC42           INIT_RAM	MOVB	R2,*R1+
  F1F4   0600           	DEC	R0
  F1F6   16FD           	JNE	INIT_RAM
                        ;
                        ; NOW MOVE PRESETS
                        ;
  F1F8   0700           	SETO	R0
  F1FA   05A0 EF40      	INC	@TIMEOUT		;THIS JUST SETS TIMEOUT TO 1 AS IT IS ALREAY 0
  F1FE   045B           	RT
                        ;
                        ;************************************************************
                        ;
                        ;	WARM BOOT ASSUMES A COLD BOOT HAS ALREADY OCCURED
                        ;	AND DISC IS JUST BEING CALIBRATED TO A KNOWN STATE
                        ;
                        ;************************************************************
                        ;
  F200   1000           WBOOT:	JMP	BOOT
                        ;
                        ;*********************************************************
                        ;
                        ;	BOOT ASSUMES MONITOR HAS BEEN INITIALISED AND SO
                        ;	THE FDC AND INTERRUPT VECTORS ARE IN VALID
                        ;
                        ;***********************************************************
                        ;
  F202   2FA0 F252      BOOT:	MESG	@BMSG2
  F206   04C2           	CLR	R2
  F208   2DA0 F28A      	CALL	@IDE_READY
                        ;
                        ;BOOT SECTOR IS LBA = 0
                        ;
  F20C   04C3           	CLR	R3		;BOOT LBA SECTOR
  F20E   0204 ED00      	LI	R4,BUFFER		;USE THIS AREA TO BOOT
  F212   2DA0 F2FE      	CALL	@READ_SECTOR
  F216   160F           	JNE	BOOT2
                        ;
                        ; GET THE LOAD ADDRESS WHICH IS LOCATED AT THE LAST 2 BYTES OF THE LOADER BUFFER
                        ;
  F218   C120 EEFE      	MOV	@BUFFER+510,R4
  F21C   C004           	MOV	R4,R0
  F21E   0201 ED00      	LI	R1,BUFFER
  F222   0202 0200      	LI	R2,512
  F226   CD31           BOOT1	MOV	*R1+,*R4+
  F228   0642           	DECT	R2
  F22A   16FD           	JNE	BOOT1
  F22C   02E0 0230      	LWPI	WORKSP		;RESET USE MONITOR LOCAL WORKSPACE
  F230   020A 0500      	LI	SP,STACKP
  F234   0450           	B	*R0		;LET THERE BE LIFE - LOAD THE SYSTEM
                        ;
                        ; --BOOT ERROR
                        ;
  F236   C801 EF3E      BOOT2	MOV	R1,@FDCSTATUS
  F23A   2FA0 F242      	MESG	@BMSG1
  F23E   0460 F044      	B	@PROMPT
                        ;
  F242   2D2D 426F      BMSG1	TEXT	'--Boot error'
  F246   6F74 2065      
  F24A   7272 6F72      
  F24E   0D0A 00        	BYTE	0DH,0AH,0
  F251   00             	EVEN
  F252   2D2D 426F      BMSG2	TEXT	'--Booting....'
  F256   6F74 696E      
  F25A   672E 2E2E      
  F25E   2E             
  F25F   0D0A 00        	BYTE	0DH,0AH,0
  F262   5041 4745      PAGE	TEXT	"PAGE: "
  F266   3A20           
  F268   00             	BYTE	0
  F269   00             	EVEN
                        
                        ;
                        ;****************************
                        ;
                        ; CHAR IN (MSB	OF R1)
                        ;
                        ;*****************************
  F26A   2F41           CIN	READ	R1	 	;GET CHAR
  F26C   2DC0           	RET
                        ;*******************************
                        ;
                        ;	CHAR OUT (MSB OF R2)
                        ;
                        ;********************************
                        ;
  F26E   04C1           COUT	CLR	R1
  F270   D042           	MOVB	R2,R1	 	;COPY CHAR TO R1
  F272   2F01           	WRITE	R1	 	;OUTPUT IT
  F274   2DC0           	RET
                        ;
                        ;************************************************
                        ;
                        ;	SELECT THE DRIVE IN R2
                        ;
                        ;************************************************
                        ;
  F276   0460 F28A      SELDSK:	B	@IDE_READY
                        
                        ;
                        ;*****************************
                        ;
                        ;--RECAL IS JUST SEEK TO TRK ZERO (RECAL IS HANDLED THERE)
                        ;
                        ;*****************************
                        ;
  F27A   2DC0           RECAL:	RET
                        
                        ;*******************************
                        ;
                        ;READ ID FIELDS
                        ;
                        ;******************************
                        ;
  F27C   2DC0           RDID	RET
                        
                        ;****************************
                        ;
                        ;READ A RECORD
                        ; 	R3 HOLDS SECTOR
                        ;	R4 HOLDS BUFFER POINTER
                        ;
                        ;*****************************
                        ;
  F27E   0460 F2FE      RDREC:	B	@READ_SECTOR
                        
                        ;****************************
                        ;
                        ;READ A TRACK
                        ; 	R3 NOT REQUIRED
                        ;	R4 HOLDS BUFFER POINTER
                        ;
                        ;*****************************
                        ;
  F282   2DC0           RDTRK	RET
                        ;
                        ;
                        ;****************************
                        ;
                        ;WRITE A TRACK
                        ; 	R3 NOT REQUIRED
                        ;	R4 HOLDS BUFFER POINTER
                        ;
                        ;*****************************
                        ;
  F284   2DC0           WRTRK	RET
                        
                        ;******************************
                        ;
                        ;WRITE A RECORD
                        ; 	R3 HOLDS SECTOR/LBA
                        ;	R4 HOLDS BUFFER POINTER
                        ;
                        ;*****************************
                        ;
  F286   0460 F31E      WRREC	B	@WRITE_SECTOR
                        
                        ;
                        ;=========START OF IDE INTERFACE ROUTINES====================
                        ;
                        ;
                        ; IDE REGISTERS - REFERENCE SEE THE SEAGATE REFERENCE MANUAL
                        ;
                        ; IDE I/O ports
  8040                  IDE_BASE_PORT:	EQU	8040H	;PARALLEL OUTPUT ADDRESS WITH MSB SET THIS IS CS0
                        
  804E                  IDE_COMMAND:	EQU	IDE_BASE_PORT+7*2
  804E                  IDE_STATUS:	EQU	IDE_BASE_PORT+7*2
  804C                  IDE_CONTROL:	EQU	IDE_BASE_PORT+6*2
  8040                  IDE_DATA:	EQU	IDE_BASE_PORT
  804C                  IDE_HEAD:	EQU	IDE_BASE_PORT + 6*2
  8048                  IDE_CYL_LSB:	EQU	IDE_BASE_PORT + 4*2
  804A                  IDE_CYL_MSB:	EQU	IDE_BASE_PORT + 5*2
  8046                  IDE_SECTOR:	EQU	IDE_BASE_PORT + 3*2
  8044                  IDE_SEC_CNT:	EQU	IDE_BASE_PORT + 2*2
  8042                  IDE_ERROR:	EQU	IDE_BASE_PORT + 1*2
                        ;
                        ; IDE STATUS REGISTER AND BIT DEFINTIONS
                        ;
  0080                  IDE_BSY:	EQU	10000000B		;80H
  0040                  IDE_DRDY:	EQU	01000000B		;40H
  0001                  IDE_ERR:	EQU	00000001B		;01H
  0020                  IDE_DWF:	EQU	00100000B		;20H  DRIVE WRITE FAULT
  0010                  IDE_DSC:	EQU	00010000B		;01H  DRIVE SEEK COMPLETE
  0010                  IDE_DRQ:	EQU	000010000B		;01H  DATA REQUEST BIT
                        ;
                        ; IDE COMMANDS - NOTE COMMAND IS IN THE MOST SIGNIFICANT BYTE
                        ;
  2000                  IDE_CMD_READ:	EQU	02000H
  3000                  IDE_CMD_WRITE:	EQU	03000H	;R = 0 FOR NO RETRY
  1000                  IDE_CMD_RECAL:	EQU	01000H	;R = 0 FOR NO RETRY
  9100                  IDE_CMD_INIT:	EQU	09100H
  EC00                  IDE_CMD_ID:	EQU	0EC00H	;GET THE DRIVE PROPERTIES
  E000                  IDE_CMD_SDOWN:	EQU	0E000H	;R = 0 FOR NO RETRY
  E100                  IDE_CMD_SUP:	EQU	0E100H	;R = 0 FOR NO RETRY
                        
  0200                  BYTSEC:	EQU	512
                        ;
                        ; CHECK THE IDE READY BIT.
                        ;
  F28A   020C 804C      IDE_READY:	LI	PORT, IDE_HEAD		;DEVICE HEAD REGISTER
  F28E   0201 A000      	LI	R1, 10100000B*256	;SPECIFY LBA MODE
  F292   3081           	LDCR	R1,BYTEWIDE		;WRITE THE COMMAND
                        
  F294   020C 804E      	LI	PORT,IDE_STATUS		;STATUS
  F298   3481           BSY1:	STCR	R1,BYTEWIDE		;GET STATUS REGISTER
  F29A   0241 8000      	ANDI	R1,10000000B * 256	;IF BUSY, THEN WAIT
  F29E   16FC           	JNE	BSY1
                        
  F2A0   020C 804E      	LI	PORT,IDE_STATUS		;STATUS
  F2A4   3481           RDY1:	STCR	R1,BYTEWIDE			;GET STATUS REGISTER
  F2A6   0241 4000      	ANDI	R1,01000000B * 256		;WAIT FOR RDY TO BE SET
  F2AA   13FC           	JEQ	RDY1
  F2AC   2DC0           	RET
                        ;
                        ; TEMPORARY INTERRUPT HANDLERS
                        ;
                        IDE_IRQ:	;LI	R0,5
                        	;WHEX	R0
  F2AE   020C 804E      	LI	PORT,IDE_STATUS		;STATUS
  F2B2   3480           	STCR	R0,BYTEWIDE
  F2B4   0380           	RTWP
                        ;
                        ; TEMPORARY INTERRUPT HANDLERS
                        ;
                        IDE_DMARQ:	;LI	R0,6
                        	;WHEX	R0
  F2B6   020C 804E      	LI	PORT,IDE_STATUS		;STATUS
  F2BA   3480           	STCR	R0,BYTEWIDE
  F2BC   0380           	RTWP
                        
                        ;
                        ; CALL THE DRIVE ID.  THIS IS NOT OF MUCH PRACTICAL USE, BUT A GOOD TEST.
                        ;
  F2BE   2DA0 F28A      DRIVE_ID:	CALL	@IDE_READY
  F2C2   020C 804E      	LI	PORT, IDE_COMMAND	;COMMAND REGISTER6
  F2C6   0201 EC00      	LI	R1, IDE_CMD_ID		; READ BUFFER
  F2CA   3081           	LDCR	R1,BYTEWIDE
  F2CC   2DA0 F34A      	CALL	@IDE_WAIT_DRQ
  F2D0   1303           	JEQ	IDE_GET_ERROR
  F2D2   2DA0 F360      	CALL	@IDE_READ_DATA
  F2D6   2DC0           	RET
                        ;
                        ;when an error occurs, we get acc.0 set from a call to ide_drq
                        ;or ide_wait_not_busy (which read the drive's status register).  If
                        ;that error bit is set, we should jump here to read the drive's
                        ;explaination of the error, to be returned to the user.  If for
                        ;some reason the error code is zero (shouldn't happen), we'll
                        ;return 255, so that the main program can always depend on a
                        ;return of zero to indicate success.
                        ;
  F2D8   020C 8042      IDE_GET_ERROR:	LI	PORT, IDE_ERROR
  F2DC   04C1           	CLR	R1
  F2DE   3481           	STCR	R1,BYTEWIDE
  F2E0   D041           	MOVB	R1,R1
  F2E2   1303           	JEQ	IGE_X		;RETURN ERROR IN MSB OF R1
  F2E4   2FA0 F2EC      	MESG	@IDE_MSG1
  F2E8   2E81           	WHEX	R1
  F2EA   2DC0           IGE_X	RET
                        
  F2EC   4944 4520      IDE_MSG1:	TEXT	"IDE ERROR: "
  F2F0   4552 524F      
  F2F4   523A 20        
  F2F7   000D 000A      	WORD	0DH,0AH,0
  F2FB   0000           
  F2FD   00             	EVEN
                        ;
                        ; READ_SECTOR
                        ;	R3 HOLDS THE LSB OF THE LBA VALUE FOR THE SECTOR WE WANT TO READ
                        ;	R4 HOLDS THE BUFFER ADDRESS
                        ;
  F2FE   C143           READ_SECTOR:	MOV	R3,R5		;SAVE THE LBA
  F300   2DA0 F33C      	CALL	@IDE_NOT_BUSY
  F304   2DA0 F388      	CALL	@IDE_WR_LBA
  F308   020C 804E      	LI	PORT, IDE_COMMAND	;COMMAND REGISTER6
  F30C   0201 2000      	LI	R1, IDE_CMD_READ	; READ BUFFER
  F310   3081           	LDCR	R1,BYTEWIDE
                        ;
  F312   2DA0 F34A      	CALL	@IDE_WAIT_DRQ
  F316   13E0           	JEQ	IDE_GET_ERROR
  F318   2DA0 F360      	CALL	@IDE_READ_DATA
  F31C   2DC0           	RET
                        ;
                        ; 	WRITE SECTOR
                        ;	R3 HOLDS THE LSB OF THE LBA VALUE FOR THE SECTOR WE WANT TO READ
                        ;	R4 HOLDS THE BUFFER ADDRESS
                        ;
                        ;
  F31E   C143           WRITE_SECTOR:	MOV	R3,R5
  F320   2DA0 F33C      	CALL	@IDE_NOT_BUSY
  F324   2DA0 F388      	CALL	@IDE_WR_LBA
  F328   020C 804E      	LI	PORT, IDE_COMMAND	;COMMAND REGISTER6
  F32C   0201 3000      	LI	R1, IDE_CMD_WRITE		; WRITE BUFFER
  F330   3081           	LDCR	R1,BYTEWIDE
                        ;
  F332   2DA0 F34A      	CALL	@IDE_WAIT_DRQ
  F336   2DA0 F374      	CALL	@IDE_WRITE_DATA
  F33A   2DC0           	RET
                        ;
                        ; WAIT FOR THE IDE DRIVE TO NOT BE BUSY
                        ;
  F33C   020C 804E      IDE_NOT_BUSY:	LI	PORT,IDE_COMMAND	;STATUS
  F340   3481           BSY2	STCR	R1,BYTEWIDE			;GET STATUS REGISTER
  F342   0241 8000      	ANDI	R1,10000000B * 256		;IF BUSY, THEN WAIT
  F346   16FC           	JNE	BSY2
  F348   2DC0           	RET
                        ;
                        ; WAIT FOR DRQ BEFORE READ DATA.  0 STATUS, ERROR
                        ;
  F34A   0700           IDE_WAIT_DRQ:	SETO	R0		;VERY CRUDE TIMEOUT
  F34C   020C 804E      	LI	PORT,IDE_COMMAND
  F350   04C1           	CLR	R1
  F352   0600           DRQ1	DEC	R0
  F354   1304           	JEQ	DRQ_X
  F356   3481           	STCR	R1,BYTEWIDE
  F358   0241 0800      	ANDI	R1,00001000B * 256	;WAUT FOR DRQ  READT, THEN WAIT
  F35C   13FA           	JEQ	DRQ1
  F35E   2DC0           DRQ_X	RET
                        ;
                        ; IDE Status Register:
                        ; bit 7: Busy 1=busy, 0=not busy
                        ;  bit 6: Ready 1=ready for command, 0=not ready yet
                        ; bit 5: DF 1=fault occured inside drive
                        ; bit 4: DSC 1=seek complete
                        ; bit 3: DRQ 1=data request ready, 0=not ready to xfer yet
                        ; bit 2: CORR 1=correctable error occured
                        ; bit 1: IDX vendor specific
                        ; bit 0: ERR 1=error occured
                        ;;------------------------------------------------------------------
                        ;
                        ; BECAUSE IDE TRANSFERS ARE IN 16 BIT WORDS AND WE ONLY HAVE ACCESS TO 8 BIT
                        ; TRANSFERS, 256 BYTES REPRESENTS AN LBA AND TWO LBA A SECTOR.  SO TWO LBAS ARE READ
                        ;
                        ; WE ENTER WITH R4 -> BUFFER
                        ;
  F360   0200 0200      IDE_READ_DATA:	LI	R0,BYTSEC
  F364   020C 8040      	LI	PORT,IDE_DATA	 	;DATA REG
  F368   3481           RL11:	STCR	R1,BYTEWIDE		;
  F36A   DD01           	MOVB	R1,*R4+
  F36C   0600           	DEC	R0
  F36E   16FC           	JNE	RL11
  F370   C040           	MOV	R0,R1
  F372   2DC0           	RET
                        ;
                        ; BECAUSE IDE TRANSFERS ARE IN 16 BIT WORDS AND WE ONLY HAVE ACCESS TO 8 BIT
                        ; TRANSFERS, 256 BYTES REPRESENTS AN LBA AND TWO LBA A SECTOR.
                        ;
                        ; WE ENTER WITH R4 -> BUFFER
                        
  F374   0200 0200      IDE_WRITE_DATA:	LI	R0,BYTSEC
  F378   020C 8040      	LI	PORT,IDE_DATA	 	;DATA REG
  F37C   D074           WL11:	MOVB	*R4+,R1
  F37E   3081           	LDCR	R1,BYTEWIDE		;
  F380   0600           	DEC	R0
  F382   16FC           	JNE	WL11
  F384   C040           	MOV	R0,R1
  F386   2DC0           	RET
                        
                        ;
                        ; WRITE THE LOGICAL BLOCK ADDRESS TO THE DRIVE'S REGISTERS
                        ; ORGANISED AS:
                        ; LBA	WORD	0,0
                        ;
                        ; LBA + 3 = HEAD   (MSB)
                        ; LBA + 2 = CYL MSB
                        ; LBA + 1 = CYL LSB
                        ; LBA + 0 = SECTOR (LSB )
                        ;
                        ; R5 HOLDS THE LSB OF THE LBA,  MSB WILL BE ZEROED FOR TIME BEING
                        ;
  F388   04E0 00A8      IDE_WR_LBA:	CLR	@LBA
  F38C   C805 00AA      	MOV	R5,@LBA + 2
  F390   D060 00A8      	MOVB	@LBA+0,R1		;GET THE FIRST MSB BYTE
  F394   0241 0F00      	ANDI	R1,0FH*256
  F398   0261 E000      	ORI	R1,0E0H*256		; 0EH IS JUST THE 1110 CODE FOR HEAD REGISTER
  F39C   020C 804C      	LI	PORT,IDE_HEAD		; IDE HEAD
  F3A0   3081           	LDCR	R1,BYTEWIDE
                        ;
  F3A2   D060 00A9      	MOVB	@LBA+1,R1
  F3A6   020C 804A      	LI	PORT,IDE_CYL_MSB	;CYLINDER MSB
  F3AA   3081           	LDCR	R1,BYTEWIDE
                        
  F3AC   D060 00AA      	MOVB	@LBA+2,R1
  F3B0   020C 8048      	LI	PORT,IDE_CYL_LSB	;CYLINDER LSB
  F3B4   3081           	LDCR	R1,BYTEWIDE
                        
  F3B6   D060 00AB      	MOVB	@LBA+3,R1
  F3BA   020C 8046      	LI	PORT,IDE_SECTOR		;CYLINDER LSB
  F3BE   3081           	LDCR	R1,BYTEWIDE
                        ;
                        ; WE NEED TO READ TWO SECTORS TO GET 512 BYTES DUE TO THE FACT THAT WE CAN'T DO 16 BIT READS/WRITES
                        ; SO TWO LBAS REPRESENT A VIRTUAL SECTOR OF 512
                        ;
  F3C0   0201 0200      	LI	R1,2*256		;
  F3C4   020C 8044      	LI	PORT,IDE_SEC_CNT		;CYLINDER LSB
  F3C8   3081           	LDCR	R1,BYTEWIDE
                        
  F3CA   2DC0           	RET
                        
                        
                        ;======================= END IDE INTERFACE ROUTINES ==============
                        ;
                        
                        ;
                        ;********************************
                        ;
                        ;INTIALISE	INT.VECTORS	ETC
                        ;
                        ;*******************************
                        ;
  F3CC   2DC0           INTSYS	RET
                        ;
                        ;********************************
                        ;
                        ;RESET	FDC
                        ;
                        ;********************************
                        ;
  F3CE   2DC0           RSET	RET
                        ;
                        ;
                        ;*******************************************
                        ;
                        ; 	SET THE TIME OUT TIMER
                        ;
  F3D0   00F0 F3D4      SETTIMER:	WORD	INTWP4,SETTIMER+4
  F3D4   020C 0080      	LI	PORT,0080H
  F3D8   1E14           	SBZ	20		;RESET INTERRUPT
  F3DA   0208 00C8      	LI	R8,200		; 200 X 16MS = 7.0SEC
  F3DE   C808 EF40      	MOV	R8,@TIMEOUT
  F3E2   1E0E           	SBZ	14
  F3E4   1D0D           	SBO	13		;LOAD INTERVAL TIMER ONLY
  F3E6   3220 F3EE      	LDCR	@INTLV2,8
  F3EA   1D14           	SBO	20		;ENABLE INTERRUPT
  F3EC   0380           	RTWP
                        ;
  F3EE   FF             INTLV2:	BYTE	255		;16.0 MILLISECONDS
  F3EF   00             	EVEN
                        ;
                        ;;*******************************************
                        ;
                        ;	SEEK TO THE TRACK NUMBER HELD IN R3
                        ;
                        ;	DRIVE # IS IN DRIVE
                        ;
                        ;********************************************
                        ;
  F3F0   2DA0 F28A      SEEK:	CALL	@IDE_READY
  F3F4   2DC0           	RET
                        ;
                        ;******************************
                        ;
                        ;	MAIN INTERRUPT ROUTINES
                        ;
                        ;********************************
                        ;
                        FDC_DRQ 	;LI	R0,3		;SHOW WHERE THE INTERRUPT CAME FROM
                        	;WHEX	R0
  F3F6   020C 8000      	LI	PORT,STSREG
  F3FA   3408           	STCR	R8		;READ THE PORT AND CLEAR THE INTERRUPT
  F3FC   0380           	RTWP
                        ;
                        ;***********************************
                        ;
                        ;	THIS INTERRUPT SIMULATES DMA CONTROL
                        ;	ORGANISED AS FOLLOWS:
                        ;
                        ;	R9 HOLDS CURRENT COMMAND I.E. STCR OR LDCR
                        ;	R8 HOLDS THE CURRENT DMA ADDRESS.
                        ; 	R12 HOLDS THE CURRENT IO PORT - GENERALLY DATREG
                        ;
                        FDC_RWINT	;LI	R0,2		;SHOW WHERE THE INTERRUPT CAME FROM
                        	;WHEX	R0
                        	;X	R9		;EXECUTE THE COMMAND SPECIFIED BY RDWRT
  F3FE   0380           	RTWP
                        ;
                        ;*********************************************************************
                        ;
                        ;	THIS INTERRUPT IS CONTROLED BY THE TIMER ON THE TMS9902
                        ;
                        ;**********************************************************************
                        ;
                        
  F400   020C 0080      INTTIMER:	LI	PORT,CRUBASE
  F404   1F19           	TB	25
  F406   160B           	JNE	TIME2
  F408   1D14           	SBO	20		;RESET INTERRUPT
  F40A   0620 EF40      	DEC	@TIMEOUT
  F40E   1607           	JNE	TIME2
  F410   05A0 EF40      	INC	@TIMEOUT
  F414   1E14           	SBZ	20		;DISABLE TIMER
  F416   020C 0000      	LI	PORT,SELMUX
  F41A   04C8           	CLR	R8
  F41C   3148           	LDCR	R8,5		;CLEAR DISKS
  F41E   0380           TIME2	RTWP
                        ;
                        ;***********************************************************************
                        ;
                        ;	MESSAGES
                        ;
                        ;************************************************************************
                        ;
  F420   0D0A 20        ERRMSG	BYTE	0DH,0AH,20H
  F423   4644 4320      	TEXT	'FDC error type: '
  F427   6572 726F      
  F42B   7220 7479      
  F42F   7065 3A20      
  F433   00             	BYTE	0
                        ;STKMSG	BYTE	0DH,0AH,20H
                        ;	TEXT	'Stack overflow at: '
                        ;	BYTE	0
  F434   2044 7269      DRVMSG	TEXT	' Drive: '
  F438   7665 3A20      
  F43C   00             	BYTE	0
  F43D   2054 7261      TRKMSG	TEXT	' Track: '
  F441   636B 3A20      
  F445   00             	BYTE	0
  F446   2053 6563      SECTMSG	TEXT	' Sector: '
  F44A   746F 723A      
  F44E   20             
  F44F   00             	BYTE	0
                        ;
                        ;***************************************************************************
                        ;
                        ;	ALL XOP's AND WORKSPACES ARE DEFINED IN THIS SECTION AND ARE USED BY ALL PROGRAMMES
                        ;	THAT INTERACT WITH THE MONITOR ROUTINES
                        ;
                        ;	NOTES.
                        ;		1. ALL INTWP'S AND XOPWP'S OVERLAP AND SO ANY INT OR XOP
                        ;	      	   FUNCTION CODE MAY ONLY USE REGISTERS R8-R10. REGISTERS R11
                        ;	      	   TO R15 ARE RESERVED FOR XOP & INT LINKAGES.
                        ;
                        ;		2. THE XOP WORKSPACES ARE JUST FOR MANAGING THE STACK AND CONTEXT
                        ;		   CALLS THE ORIGINAL WP IS PRESERVED AFTER THE CALL, WHICH MEANS
                        ;		   THAT CALLING ROUTINES SHARE THE SAME REGISTERS.
                        ;
                        ;		3. EVEN THOUGH R9 & R10 ARE GENERALLY USED AS STACK REGISTERS
                        ;		   THIS DOES NOT APPLY IN INTERRUPT WORKSPACE WHERE THEY CAN'T
                        ;		   BE USED FOR THAT PURPOSE - SIMPLY BECAUSE THE STACK POINTER
                        ;		   IS NOT PASSED TO THE NEW WORKSPACE.  THEY CAN BE COPIED USING
                        ;		   THE R13 INDEX IF NEEDED AS R13 POINTS TO THE CALLING ROUTINE'S WORKSPACE
                        ;
                        ;*****************************************************************************
                        ;
                        ;	EVEN
  00B0                  INTWP0	EQU	INTWP		;INTERRUPT WORKSPACE
  00C0                  INTWP1	EQU	INTWP0+16		;ONLY 7 ALLOWED
  00D0                  INTWP2	EQU	INTWP1+16
  00E0                  INTWP3	EQU	INTWP2+16
  00F0                  INTWP4	EQU	INTWP3+16
  0100                  INTWP5	EQU	INTWP4+16
  0110                  INTWP6	EQU	INTWP5+16
  0120                  INTWP7	EQU	INTWP6+16
                        ;
                        ;    NOW XOP'S
                        ;
  0130                  XOPWP0	EQU	XOPWP
  0140                  XOPWP1	EQU	XOPWP0+16
  0150                  XOPWP2	EQU	XOPWP1+16
  0160                  XOPWP3	EQU	XOPWP2+16
  0170                  XOPWP4	EQU	XOPWP3+16
  0180                  XOPWP5	EQU	XOPWP4+16
  0190                  XOPWP6	EQU	XOPWP5+16
  01A0                  XOPWP7	EQU	XOPWP6+16
  01B0                  XOPWP8	EQU	XOPWP7+16
  01C0                  XOPWP9	EQU	XOPWP8+16
  01D0                  XOPWP10	EQU	XOPWP9+16
  01E0                  XOPWP11	EQU	XOPWP10+16
  01F0                  XOPWP12	EQU	XOPWP11+16
  0200                  XOPWP13	EQU	XOPWP12+16
  0210                  XOPWP14	EQU	XOPWP13+16
  0220                  XOPWP15	EQU	XOPWP14+16
  0230                  XOPWP16	EQU	XOPWP15+16
                        ;
                        ;	AORG	XOPWP15+32
                        ;
                        ;
                        ;	DEFINE ALL THE XOP ROUTINES
                        ;
                        ;================================================
                        ;
                        ; DOS EMULATOR - THIS IS NEEDED WHEN CODE IN MEMORY SEGMENTS NEED TO ACCESS BDOS
                        ; CALLING METHOD:  BDOS
                        ; REGISTERS:	   R2 AND R3 CONTAIN FUNCTION NUMBER AND ARGUMENT
                        ;
                        ; IT WORKS BECAUSE THE TMS99105A WILL CLEAR THE PSEL BIT AND FORCE THE SIGNAL HIGH THUS SELECTING PAGE 0
                        ; OR COMMON MEMORY.  RTWP, AND R15 WILL RETURN IT TO ITS ORIGINAL VALUE.
                        ;
                        ;================================================
                        ;
  F450   C0AD 0004      XOP0:	MOV	@2*R2(R13),R2		;GET FUNCTION
  F454   C0ED 0006      	MOV	@2*R3(R13),R3		;GET PARAMETER
  F458   C220 0086      	MOV	@BDOSV,R8
  F45C   2D98           	CALL	*R8
  F45E   0380           	RTWP
                        ;
                        ;============================================
                        ;	SUBROUTINE LONG RETURN
                        ;	CALLING METHOD:	RETF
                        ;
                        ;	STACK ORDER
                        ;	SEGMENT REGISTER (16 bits, Upper 8 bits Called Page, Lower 8 bits return page)
                        ;	INSTRUCTION POINTER
                        ;============================================
                        ;
  F460   C2AD 0014      XOP1:	MOV	@2*SP(R13),SP		;GET STACK POINTER
  F464   C27A           	MOV	*SP+,R9		;GET SEGMENT REGISTER
  F466   C3BA           	MOV	*SP+,R14		;MOVE IP/PC INTO R14 FOR CALL
  F468   CB4A 0014      	MOV	SP,@2*SP(R13)		;GET UPDATED STACK POINTER
                        ;
                        ; RESTORE CALLING PAGE
                        ;
  F46C   CB49 0012      	MOV	R9,@2*R9(R13)		;RESTORE SEGMENT REGISTER
  F470   C209           	MOV	R9,R8
  F472   06C8           	SWPB	R8		; GET CALLING PAGE
  F474   0A78           	SLA	R8,7
  F476   020C 80C0      	LI	PORT,MEMBASE
  F47A   3088           	LDCR	R8,BYTEWIDE		;GET PAGE VALUE FROM STEP ABOVE
  F47C   D208           	MOVB	R8,R8		;IS THIS PAGE 0?
  F47E   1303           	JEQ	XOP1A;		;YES
  F480   026F 0080      	ORI	R15,0080H		;YES, SET PSEL BIT
  F484   0380           	RTWP
  F486   024F FF7F      XOP1A	ANDI	R15,0FF7FH		;YES, CLEAR PSEL BIT
  F48A   0380           	RTWP			;RETURN
                        ;
                        ;======================================================================
                        ;
                        ;   XOP2: SETPAGE - SETS A NEW PAGE REGISTER USING THE SEGMENT REGISTER R9
                        ;   FOR THIS NEW VERSION TO WORK, THERE MUST BE COMMON MEMORY (6116 SRAM DEFINED)
                        ;
                        ;   PAGE VALUE ON SBC IS D0,D1,D2 AND D3 WHERE D0 IS MSB SO WE NEED TO SHIFT
                        ;   LOWER 4 BITS IN TO THE TOP NYBLLE
                        ;
                        ;   NOTE, THIS ROUTINE DOES NOT SELECT A NEW MEMORY SEGMENT IT JUST SIMILAR
                        ;   TO A MEMORY MAP REGISTER.  IT IS SET BUT ONLY ACTIVE ONCE THE PSEL BIT
                        ;   IN THE STATUS REGISTER IS SET.  THIS IS HOW A MEMORY MAPPER WORKS.
                        ;
                        ;   R9 IS THE SEGMENT REGISTER.  HIGH BYTE IS SEGMENT REGISTER,
                        ;   LOW BYTE IS THE RETURN SEGMENT USED BY FAR_CALLS AND RETF
                        ;
                        ;
                        ;=======================================================================
                        ;
  F48C   D22D 0012      XOP2:	MOVB	@2*R9(R13),R8
  F490   0A78           	SLA	R8,7		;SHIFT INTO MSB
  F492   020C 80C0      	LI	PORT,MEMBASE
  F496   3088           	LDCR	R8,BYTEWIDE		;GET PAGE VALUE FROM STEP ABOVE
  F498   0380           	RTWP
                        ;
                        ;***********************************************
                        ; LONG CALL XOP.
                        ;
                        ;  XOPWP3 IS THE WORKSPACE WE NEED TO OPERATE WITHIN WHICH IS IN PAGED MEMORY NOT COMMON
                        ;
                        ;  CALLING:	LI   R9, MEMORY SEGMENT
                        ;  	LONG_CALL FUNCTION1, FAR_CALL
                        ;
                        ; R13 SAVE WP REGISTER
                        ; R14 SAVED PC REGISTER
                        ; R15 SAVE ST REGISTER
                        ;
                        ; STEPS:
                        ; PUSH PC (IP)  ONTO STACK
                        ; PUSH CODE SEGMENT ONTO STACK ( 0xCCRRH CC:PAGE, RR:RETURN PAGE )
                        ; SET RTWP REGISTERS
                        ; SET NEWPAGE
                        ; SET PSEL BIT IN STATUS REGISTER TO 1
                        ; RTWP TO NEW PROCEDURE/ROUTINE
                        ;
                        ;************************************************
                        ;
  F49A   C2AD 0014      XOP3:	MOV	@2*SP(R13),SP 		;GET STACK POINTER FROM CALLING WP IN R13
  F49E   064A           	DECT	SP
  F4A0   C68E           	MOV	R14,*SP		;PUSH SAVED PC ONTO STACK
  F4A2   064A           	DECT	SP
  F4A4   CB4A 0014      	MOV	SP,@2*SP(R13)		;UPDATE STACK POINTER
  F4A8   C6AD 0012      	MOV	@2*R9(R13),*SP		;MOVE SEGMENT REGISTER ONTO STACK
  F4AC   C38B           	MOV	R11,R14		;MOV EFFECTIVE ADDRESS INTO R14
  F4AE   C21A           	MOV	*SP,R8		;GET SEGMENT REGISTER
  F4B0   0A78           	SLA	R8,7		;CURRENTLY ONLY TWO PAGES AND D0 IS FROM D7
  F4B2   020C 80C0      	LI	PORT,MEMBASE
  F4B6   3088           	LDCR	R8,BYTEWIDE		;GET PAGE VALUE FROM STEP ABOVE
                        ;
                        ; NOW BRING PSEL LOW TO ENABLE MAPPING.
                        ; BY SETTING THE PSEL BIT IN THE STATUS REGISTER
                        ;
                        ;
  F4B8   D208           	MOVB	R8,R8		;IS THIS PAGE 0?
  F4BA   1303           	JEQ	XOP3A;		;YES
  F4BC   026F 0080      	ORI	R15,0080H		;YES, SET PSEL BIT
  F4C0   0380           	RTWP
  F4C2   024F FF7F      XOP3A	ANDI	R15,0FF7FH		;YES, CLEAR PSEL BIT
  F4C6   0380           	RTWP			;SWITCH TO NEW MEMORY SEGMENT PRESERVING USER WORKSPACE
                        ;
                        ;
                        ;**********************************************
                        ; PUSH REGISTERS R0 to RN ONTO THE STACK
                        ;*********************************************
                        ;
  F4C8   C20D           XOP4	MOV	R13,R8		;GET THE EFFECTIVE ADDRESS OF CALLING WORKSPACE
  F4CA   C2AD 0014      	MOV	@2*R10(R13),R10	;GET SYSTEM STACK POINTER
  F4CE   064A           XOP4A	DECT	R10		;DECREMENT STACK POINTER
  F4D0   C6B8           	MOV	*R8+,*R10
  F4D2   82C8           	C	R8,R11		;KEEP PUSHING REGISTERS (R11 HOLDS EFFECTIVE ADDRESS OF REGISTER RN)
  F4D4   12FC           	JLE	XOP4A
  F4D6   CB4A 0014      	MOV	R10,@2*R10(R13)	;UPDATE THE STACK POINTER
  F4DA   0380           	RTWP
                        ;
                        ;***********************************************
                        ; POPS REGISTERS R0 to RN OFF THE STACK
                        ;************************************************
                        ;
  F4DC   C2AD 0014      XOP5	MOV	@2*R10(R13),R10	;GET STACK POINTER
  F4E0   C6FA           XOP5A	MOV	*R10+,*R11		;GET FIRST REGISTER
  F4E2   064B           	DECT	R11		;DECT TWO EFFECTIVE ADDRESS, IE RN
  F4E4   834B           	C	R11,R13		;COMPARE AGAINST WORKSPACE TOP ADDRESS IE R0
  F4E6   14FC           	JHE	XOP5A
  F4E8   CB4A 0014      	MOV	R10,@2*R10(R13)
  F4EC   0380           	RTWP
                        
                        ;
                        ;************************************************
                        ;	CALL A SUBROUTINE
                        ;	CALLING METHOD:   CALL SUBROUTINE_ADDRESS
                        ;*************************************************
                        ;
  F4EE   C2AD 0014      XOP6	MOV	@2*SP(R13),SP 	;GET STACK POINTER FROM CALLING WP IN R13
  F4F2   064A           	DECT	SP
                        ;	C	R10,@2*R9(R13)	;CHECK FOR STACK OVERFLOW
                        ;	JLE	STACKERR		;O/P STACK OVERFLOW MESSAGE
  F4F4   C68E           	MOV	R14,*SP		;PUSH SAVED PC ONTO STACK
                        ;	ANDI	R14,1		;CHECK FOR ODD
                        ;	JNE    	ODDMSG
  F4F6   C38B           	MOV	R11,R14		;MOVE EA INTO R14 FOR CALL
  F4F8   CB4A 0014      	MOV	SP,@2*SP(R13)	;UPDATE STACK POINTER
  F4FC   0380           	RTWP
                        
                        ;
                        ;============================================
                        ;	SUBROUTINE RETURN
                        ;	CALLING METHOD:	RET
                        ;============================================
                        ;
  F4FE   C2AD 0014      XOP7	MOV	@2*SP(R13),SP	;GET STACK POINTER
  F502   C3BA           	MOV	*SP+,R14		;MOVE EA INTO R14 FOR CALL
  F504   CB4A 0014      	MOV	SP,@2*SP(R13)	;GET UPDATED STACK POINTER
  F508   0380           	RTWP			;RETURN
                        ;
                        ;*************************************************
                        ;	PUSH DATA/REGISTER ONTO THE STACK
                        ;	USES CALLER'S WP AND STACK POINTERS
                        ;*************************************************
                        ;
                        XOP8	;MOV	@FREEMEM,@2*R9(R13)	;UPDATE FREE MEMORY POINTER IE STACK LIMIT
  F50A   C2AD 0014      	MOV	@2*R10(R13),R10
  F50E   064A           	DECT	R10
                        ;	C	R10,@2*R9(R13)	;CHECK FOR OVERFLOW
                        ;	JLE	STACKERR
  F510   C69B           	MOV	*R11,*R10		;MOVE DATA FROM EFFECTIVE ADDRESS
  F512   CB4A 0014      	MOV	R10,@2*R10(R13)
  F516   0380           	RTWP
                        ;
                        ;	POP DATA/REGISTER OFF STACK
                        ;
  F518   C2AD 0014      XOP9	MOV	@2*R10(R13),R10
  F51C   C6FA           	MOV	*R10+,*R11
  F51E   CB4A 0014      	MOV	R10,@2*R10(R13)
  F522   0380           	RTWP
                        ;
                        ;=====================================================
                        ;	WRITE A HEX CHARACTER
                        ;
                        ;	CALLING METHOD:   WHEX Reg
                        ;
                        ;	FUNCTION: WRITE CONTENTS OF Reg AS 4 HEX DIGITS
                        ;========================================================
                        ;
  F524   C31B           XOP10	MOV	*R11,R12		;GET VALUE
  F526   0209 0004      	LI 	R9,4		;SET COUNTER TO 4 DIGITS
                        ;
  F52A   C20C           XOP10A	MOV	R12,R8		;MOVE 4 DIGITS INTO R8R
  F52C   09C8           	SRL	R8,12		;ISOLATE HEX DIGIT
  F52E   0A88           	SLA	R8,8		;BYTE ALIGN1
  F530   0288 0900      	CI	R8,0900H		;IS THIS NUMERIC
  F534   1202           	JLE	XOP10B		;YES
  F536   0228 0700      	AI	R8,0700H		;ALPHA ADJUST
                        ;
  F53A   0228 3000      XOP10B	AI	R8,'0'*256		;NUMERIC TO ASCII
  F53E   2F08           	WRITE	R8		;O/P THE HEX DIGIT
  F540   0BCC           	SRC	R12,12		;ALIGN NEXT DIGIT
  F542   0609           	DEC	R9		;IF FINISHED EXIT
  F544   16F2           	JNE	XOP10A
  F546   0380           	RTWP
                        ;
                        ;===========================================================
                        ;	READ IN A 16 BIT HEX CHARACTER
                        ;
                        ;	CALL:   RHEX RN
                        ;
                        ;	FUNCTION: READ  CONTENTS INTO  RN AS 4 HEX DIGITS
                        ;============================================================
                        ;
  F548   04CC           XOP11	CLR	R12		;CLEAR ACCUMULATOR
  F54A   2F4A           XOP11A	READ	R10		;GET AN INPUT CHARACTER
  F54C   2F0A           	WRITE	R10		;ECHO THE CHARACTER
                        ;
                        ;	CHECK FOR VALID HEX INPUT
                        ;
  F54E   028A 3000      XOP11B	CI	R10,'0'*256		;BELOW MIN NUMERIC ?
  F552   1A10           	JL	NOTHEX		;IF YES, JUMP
  F554   028A 3900      	CI	R10,'9'*256		;ABOVE MAX NUMERIC ?
  F558   1208           	JLE	GOTONE		;IF NO, JUMP
  F55A   028A 4100      	CI	R10,'A'*256		;BELOW MIN ALPHA ?
  F55E   1A0A           	JL	NOTHEX		;IF YES JUMP
  F560   028A 4600      	CI	R10,'F'*256		;ABOVE MAX ALPHA ?
  F564   1B07           	JH	NOTHEX		;IF YES, JUMP
  F566   022A 0900      	AI	R10,0900H		;ALPHA ADJUST
  F56A   0A4A           GOTONE	SLA	R10,4		;ISOLATE DIGIT
  F56C   09CA           	SRL	R10,12		;WORD ALIGN DIGIT
                        ;
                        ;
                        ; DIGIT TO ACCUMULATOR
                        ;
  F56E   0A4C           	SLA	R12,4		;MAKE ROOM FOR NEW DIGIT
  F570   A30A           	A	R10,R12		;ADD NEW DIGIT IN
  F572   10EB           	JMP	XOP11A		;GO GET NEXT DIGIT
  F574   C6CC           NOTHEX	MOV	R12,*R11		;RETURN THE VALUE
  F576   0380           	RTWP
                        ;
                        ;==================================================
                        ;	WRITE A CHARACTER
                        ;==================================================
                        ;
  F578   020C 0080      XOP12	LI	R12,CRUBASE
  F57C   1D10           	SBO	16
  F57E   1F16           XOP12A	TB	22
  F580   16FE           	JNE	XOP12A
  F582   321B           	LDCR	*R11,8
  F584   1E10           	SBZ	16
  F586   0380           	RTWP
                        ;
                        ;====================================================
                        ;	READ CHARACTER INTO LEFT BYTE (MSB)
                        ;====================================================
                        ;
  F588   020C 0080      XOP13	LI	R12,CRUBASE
  F58C   1F15           XOP13A	TB	21		;RECEIVE BUFFER REG FULL ?
  F58E   16FE           	JNE	XOP13A		;NO
  F590   04DB           	CLR	*R11
  F592   361B           	STCR	*R11,8
  F594   1E12           	SBZ	18		;SHOW WE RECEIVED CHARACTER
  F596   0380           	RTWP
                        ;
                        ;=========================================================
                        ;
                        ;	OUTPUT A NULL TERMINATED STRING
                        ;	MESG ADDR
                        ;
                        ;==========================================================
                        ;
  F598   D33B           XOP14	MOVB	*R11+,R12		;GET THE CHARACTER
  F59A   1302           	JEQ	XOP14A		;IF ZERO EXAT
  F59C   2F0C           	WRITE	R12
  F59E   10FC           	JMP	XOP14		;RETURN
  F5A0   0380           XOP14A	RTWP
                        
                        ;=================================================
                        
                        ;
                        ;
                        ;************************************************
                        ;	DEBUG AND TRACING INFORMATION
                        ;
                        ;	DEBUG @MODULE_NAME
                        ;
                        ;	THE MODULE_ID WILL BE PRINTED SO THAT THE USER CAN TELL WHICH
                        ;	MODULE IS BEING DEBUGGED.  KEEP TO 8 BYTES AND NULL TERMINATED
                        ;
                        ;
                        ;*************************************************
                        ;
  F5A2   0208 000A      XOP15:	LI	R8,10		;KEEP NAMES TO 8 BYTES
  F5A6   0209 EF20      	LI	R9,DEBUG_NAME
  F5AA   DE7B           XOP15_NAME:	MOVB	*R11+,*R9+		;SAVE THE NAME
  F5AC   1305           	JEQ	XOP15_MAIN
  F5AE   0608           	DEC	R8
  F5B0   16FC           	JNE	XOP15_NAME
  F5B2   0208 0000      	LI	R8,0;		;NULL TERMINATE
  F5B6   D648           	MOVB	R8,*R9
                        
                        ;
                        ; 	NOW SAVE THE TRACE DATA
                        ;
  F5B8   020B EF2A      XOP15_MAIN:	LI	R11, DEBUG_BUFFER
  F5BC   CECE           	MOV	R14,*R11+		;STORE NEXT STATEMENT PROGRAMME COUNTER
  F5BE   CECD           	MOV	R13,*R11+		;STORE WP
  F5C0   CECF           	MOV	R15,*R11+		;STORE STATUS
  F5C2   0208 0010      	LI	R8,16		;16 REGISTERS
                        XOP15_REGS:
  F5C6   CEFD           	MOV 	*R13+,*R11+		;COPY REGISTERS
  F5C8   0608           	DEC	R8
  F5CA   16FD           	JNE	XOP15_REGS
  F5CC   022D FFE0      	AI	R13,-32		;RESTOR WORKSPACE REGISTER LOCATION
  F5D0   1000           	JMP	LIST_REG
                        ;
                        ;
                        ; PRINT OUT DEBUGGING/TRACE PC, STATUS AND REGISTERS
                        ;
  F5D2   0209 EF2A      LIST_REG:	LI	R9,DEBUG_BUFFER
  F5D6   0208 0010      	LI	R8,16
  F5DA   2FA0 F038       	MESG	@CRLF		;PRINT INDENTATION
  F5DE   2FA0 EF20       	MESG	@DEBUG_NAME		;PRINT THE NAME OF THE MODULE
  F5E2   2FA0 F669       	MESG	@SP_REG
  F5E6   C2AD 0014       	MOV	@2*SP(R13),R10	;GET STACK POINTER
  F5EA   2E9A            	WHEX	*R10		;PRINT CONTENTS
  F5EC   2FA0 F662      	MESG	@PC_REG		;PRINT " PC="
  F5F0   2EB9           	WHEX	*R9+
  F5F2   2FA0 F654      	MESG	@WP_REG		;WORKSPACE POINTER
  F5F6   2EB9           	WHEX	*R9+
  F5F8   2FA0 F65B      	MESG	@ST_REG		;PRINT " ST="
  F5FC   C2F9           	MOV	*R9+,R11		;GET STATUS REGISTER VALUE
  F5FE   2E8B           	WHEX	R11
                        ;	MESG	@EA_REG		;EFFECTUVE ADDRESS POINTER
                        ;	WHEX	*R9+
                        ;
  F600   020A 2000      	LI	R10,' '*256		;PRINT SPACE
  F604   2F0A           	WRITE	R10
  F606   020A 3000      LIST_REGA:	LI	R10,30H*256		;PRINT 0
  F60A   0A1B           	SLA	R11,1
  F60C   1802           	JOC	LIST_REGB
  F60E   2F0A           	WRITE	R10
  F610   1003           	JMP	LIST_REGC
  F612   022A 0100      LIST_REGB:	AI	R10,1*256		;PRINT 1
  F616   2F0A           	WRITE	R10
  F618   0608           LIST_REGC:	DEC	R8
  F61A   16F5           	JNE	LIST_REGA
  F61C   04CA           	CLR	R10
  F61E   2FA0 F038      LIST_REG1:	MESG	@CRLF		;PRINT CR,LF
  F622   0208 5200      LIST_REG2:	LI	R8,'R'*256
  F626   2F08           	WRITE	R8		;PRINT "R"
  F628   2F2A F07A      	WRITE	@NUMTAB(R10)	;PRINT REGISTER NO
  F62C   2F2A F07B      	WRITE	@NUMTAB+1(R10)	;PRINT REGISTER NO
  F630   0208 3D00      	LI	R8,'='*256
  F634   2F08           	WRITE	R8
  F636   2EB9           	WHEX	*R9+		;PRINT REGISTER CONTENTS
  F638   05CA           	INCT	R10
  F63A   028A 0020      	CI	R10,20H
  F63E   1307           	JEQ	LIST_EXIT
  F640   0208 2000      	LI	R8,' '*256		;PRINT A SPACE
  F644   2F08           	WRITE	R8
  F646   26A0 F0DA      	CZC	@MASK15,R10
  F64A   13E9           	JEQ	LIST_REG1
  F64C   10EA           	JMP	LIST_REG2
  F64E   2FA0 F038      LIST_EXIT:	MESG	@CRLF		;PRINT INDENTATION
  F652   0380           	RTWP
                        
  F654   2057 5020      WP_REG:	TEXT	' WP = '
  F658   3D20           
  F65A   00             	BYTE	0
  F65B   2053 5420      ST_REG:	TEXT	' ST = '
  F65F   3D20           
  F661   00             	BYTE	0
  F662   2050 4320      PC_REG:	TEXT	' PC = '
  F666   3D20           
  F668   00             	BYTE	0
  F669   202A 5350      SP_REG:	TEXT	' *SP = '
  F66D   203D 20        
  F670   00             	BYTE	0
  F671   2045 4120      EA_REG:	TEXT	' EA = '
  F675   3D20           
  F677   00             	BYTE	0
  F678                  	EVEN
                        ;NUMTAB:	TEXT	'0 1 2 3 4 5 6 7 8 9 101112131415'
                        ;MASKF:	WORD	00FH
                        ;
                        ;************************************************************
                        ;
                        ;THIS SECTION HOLDS ALL THE TIBUG_MONITOR INSTRUCTION
                        ;	Q (QBOOT), U (HEXLOAD),V (HEXLOAD2),G (GO TO) M(MOVE)
                        ;	F(FIND),O (OUTPUT), W (WORK SPACE),R (PRINT_REGS),
                        ;	P(PRINT),X(XCUTE),L(LOWW),H(SETBP),S(STEP),T(TRACE),
                        ;	/(CHAR),.(INSTANT),O(OPEN)
                        ;
                        ;	ONLY PARTIAL IMPLEMENTATION.  FULL CODE IN TIMON.A99 SOURCE
                        ;*********************************************************
                        ;	BOOT INSTRUCTION
                        ;
  F678   0460 F202      QBOOT	B	@BOOT		;BRANCH HERE TO LOAD THE SYSTEM
                        ;
                        ;***********************************************************
                        ;	GO INSTRUCTION G
                        ;
  F67C   163A           GO:	JNE	MON00A		;JNE ON HEXIN FLAG
  F67E   0452           	B	*R2
                        ;
                        ;*************************************************************
                        ; INSTRUCTION PRINT OUT REGISTERS
                        ;
  F680   0204 00FA      PRINT_REGS:	LI	R4,2*R13+INTWP3
  F684   C114           	MOV	*R4,R4		;R4:=USER WORKSPACE BY DEFAULT
  F686   C0C3           	MOV	R3,R3		;TEST HEXIN FLAG
  F688   1601           	JNE	REGIST0
  F68A   C102           	MOV	R2,R4
  F68C   0244 FFFE      REGIST0 	ANDI	R4,0FFFEH		;MAKE ADDRESS EVEN
  F690   2FA0 F117      	MESG	@MESS03+1		;PRINT INDENTATION
  F694   2FA0 F654      	MESG	@WP_REG		;PRINT "WP="
                        ;	MOV	R4,R2		;PRINT WORKSPACE ADDRESS
  F698   2E84           	WHEX	R4		;PRINT WORKSPACE ADDRESS
  F69A   04C5           	CLR	R5
                        ;	CLR	R10
  F69C   2FA0 F117      REGIST1	MESG	@MESS03+1		;PRINT SPACE, CR,LF
  F6A0   0209 5200      REGIST2	LI	R9,'R'*256
  F6A4   2F09           	WRITE	R9		;PRINT "R"
  F6A6   2F25 F07A      	WRITE	@NUMTAB(R5)		;PRINT REGISTER NO
  F6AA   2F25 F07B      	WRITE	@NUMTAB+1(R5)	;PRINT REGISTER NO
  F6AE   2FA0 F11E      	MESG	@MESS04
                        	;	R9,'='*256
                        	;WRITE	R9		;PRINT REGISTER CONTENTS
  F6B2   2EB4           	WHEX	*R4+		;BL	@HEXOUT
  F6B4   0209 2000      	LI	R9,' '*256
  F6B8   2F09           	WRITE	R9
  F6BA   05C5           	INCT	R5
  F6BC   0285 0020      	CI	R5,20H		;HAVE 16 REGISTERS BEEN PRINTED?
  F6C0   1318           	JEQ	MON00A
  F6C2   2560 F0DC      	CZC	@MASK3,R5		;ODD REGISTER, IF SO CRLF
  F6C6   13EA           	JEQ	REGIST1
  F6C8   10EB           	JMP	REGIST2
                        ;
                        ;
                        ; INSTRUCTION ' ' OPEN INSTRUCTION.  A '-' DELIMITER OPENS THE PREVIOUS LOCATION
                        ;
  F6CA   1601           OPEN:	JNE	OPEN00		;JNE ON HEXIN FLAG
  F6CC   C382           	MOV	R2,R14
  F6CE   024E FFFE      OPEN00	ANDI	R14,0FFFEH		;MAKE ADDRESS EVEN
  F6D2   06A0 F6F6      OPEN01	BL	@PADDRC		;PRINT ADDRESS AND CONTENTS
  F6D6   06A0 F122      	BL 	@HEXIN
  F6DA   1601           	JNE	OPEN02		;JNE ON HEXIN FLAG
  F6DC   C782           	MOV	R2,*R14
  F6DE   0281 2000      OPEN02	CI	R1,' '*256 		;LAST CHARACTER=" "?
  F6E2   1602           	JNE	OPEN03
  F6E4   05CE           	INCT 	R14
  F6E6   10F5           	JMP	OPEN01
  F6E8   0281 2D00      OPEN03	CI	R1,'-'*256 		;LAST CHARACTER="-"?
  F6EC   1602           	JNE	MON00A
  F6EE   064E           	DECT	R14
  F6F0   10F0           	JMP	OPEN01
  F6F2   0460 F044      MON00A	B	@PROMPT
                        ;
                        ; PRINT ADDRESS IN R14
                        ;
  F6F6   2FA0 F117      PADDRC	MESG	@MESS03+1		;PRINT INDENTATION
  F6FA   2E8E           	WHEX	R14		;PRINT ADDRESS
  F6FC   2FA0 F11C      	MESG	@MESS03+6		;PRINT "  "
  F700   2E9E           	WHEX	*R14		;PRINT CONTENTS OF ADDRESS
                        	;BL	@HEXOUT
  F702   2FA0 F11C      	MESG	@MESS03+6		;PRINT "  "
  F706   045B           	RT			;RETURN FROM BL
                        ;
                        ; 	INSTRUCTION OUTPUT 'O'
                        ;
  F708   C10F           OUTPUT:	MOV	R15,R4
  F70A   C0C3           	MOV	R3,R3
  F70C   1601           	JNE	OUTPUT0
  F70E   C102           	MOV	R2,R4
  F710   0244 FFFE      OUTPUT0 	ANDI	R4,0FFFEH		;MAKE ADDRESS EVEN
  F714   C144           	MOV	R4,R5
  F716   0245 FFF0      	ANDI	R5,0FFF0H
  F71A   0225 0080      	AI	R5,80H
  F71E   2FA0 F117      OUTPUT1	MESG	@MESS03+1		;PRINT INDENTATION
                        ;	MOV	R4,R2
                        ;	BL	@HEXOUT0		;PRINT ADDRESS
  F722   2E84           	WHEX	R4		;PRINT ADDRESS
  F724   2FA0 F11B      	MESG	@MESS03+5		;PRINT " "
                        	;MOV	*R4+,R2
                        	;BL	@HEXOUT
  F728   2EB4           OUTPUT2 	WHEX	*R4+
  F72A   2FA0 F11C      	MESG	@MESS03+6		;PRINT " "
  F72E   8144           	C	R4,R5
  F730   1304           	JEQ	OUTPUT3
  F732   2520 F0DA      	CZC	@MASK15,R4
  F736   13F3           	JEQ	OUTPUT1
  F738   10F7           	JMP	OUTPUT2
  F73A   2F41           OUTPUT3	READ	R1		;GET CHARACTER
  F73C   0281 2000      	CI	R1,' '*256
  F740   16D8           	JNE	MON00A
  F742   0225 0080      	AI	R5,80H		;AN EXTRA 4 LINES
  F746   10EB           	JMP	OUTPUT1
                        ;
                        ; INSTRUCTION W
                        ;
  F748   1603           WP:	JNE	WP00		;JNE ON HEXIN FLAG
  F74A   C802 00FA      	MOV	R2,@2*R13+INTWP3
  F74E   10D1           	JMP	MON00A
  F750   2FA0 F116      WP00	MESG	@MESS03			;PRINT INDENTATION
  F754   2FA0 F654      	MESG	@WP_REG			;PRINT "WP="
  F758   C0A0 00FA      	MOV	@2*R13+INTWP3,R2
  F75C   2E82           	WHEX	R2
  F75E   10C9           	JMP	MON00A
                        
                        ;
                        ;**************************************************************
                        ;	COMMAND LOAD HEX FILE
                        ;
                        ;	ALGORITHM TAKEN FROM DDJ #22
                        ;
                        ;	R3  HOLDS CHECKSUM
                        ;	R4  HOLDS RECORD LENGTH
                        ;	R5  HOLDS LOAD ADDRESS
                        ;
                        ;***************************************************************
                        ;
  F760   0202 3A00      HEXLOAD:	LI	R2,':'*256
  F764   2F41           	READ	R1		;SEARCH FOR ':'
  F766   9081           	CB	R1,R2		;COMPARE BYTE FOR :
  F768   16FB           	JNE	HEXLOAD
  F76A   2F20 F146      	WRITE	@DOT		;DEBUG INFO
  F76E   04C3           	CLR 	R3		;CLEAR CHECKSUM
  F770   2DA0 F7EE      	CALL	@NEXTBYTE		;GET RECORD LENGTH
  F774   D101           	MOVB	R1,R4
  F776   0984           	SRL	R4,8		;LENGTH IN R4
  F778   1313           	JEQ	INST_EXIT		;WERE DONE
  F77A   2DA0 F808      	CALL	@NEXTADDR		;GET LOAD ADDRESS
  F77E   C141           	MOV	R1,R5
  F780   2DA0 F7EE      	CALL	@NEXTBYTE		;GET RECORD TYPE
  F784   C104           HL_12	MOV	R4,R4		;IF RL=0 GO TO A13
  F786   1305           	JEQ	HL_13
  F788   2DA0 F7EE      	CALL	@NEXTBYTE
  F78C   DD41           	MOVB	R1,*R5+		;STORE DATA IN MEMORY
  F78E   0604           	DEC	R4		;REDUCE RECORD LENGTH
  F790   10F9           	JMP	HL_12
  F792   2DA0 F7EE      HL_13	CALL	@NEXTBYTE		;GET CHECKSUM BYTE
                        ;	MOVB	R3,R3		;CHECK FOR ZERO
  F796   13E4           	JEQ	HEXLOAD
                        ;
                        ; FALL THROUGH TO ERROR
                        ;
  F798   2F41           HL_14	READ	R1		;READ ANY RUBBISH
  F79A   2F20 F14A      	WRITE	@LOADERR		;TELL TERMINAL SYSTEM TO STOP
  F79E   2F41           	READ	R1		;READ ANY RUBBISH
  F7A0   0460 F044      INST_EXIT:	B	@PROMPT		;BACK TO TIMON
                        ;
                        ;
                        ;**************************************************************
                        ;	COMMAND LOAD HEX FILE 2
                        ;	SEMENTED MEMORY PAGES VERSION (V)
                        ;	ADDRESS FORMAT:
                        ;	  A SINGLE BYTE PAGE NUMBER IS NOW INSERTED BEFORE EACH 16 BIT ADDRESS.
                        ;	  IF IT IS ZERO THEN LOAD TO PAGE 0, IF NOT LOAD TO THE PAGE IN THE FIELD
                        ;	  I.E.  00XXXX, 01XXXX ETC
                        ;;
                        ;	ALGORITHM TAKEN FROM DDJ #22
                        ;
                        ;	R3  HOLDS CHECKSUM
                        ;	R4  HOLDS RECORD LENGTH
                        ;	R5  HOLDS LOAD ADDRESS
                        ;
                        ;***************************************************************
                        ;
  F7A4   0202 3A00      HEXLOAD2:	LI	R2,':'*256
  F7A8   2F41           	READ	R1		;SEARCH FOR ':'
  F7AA   9081           	CB	R1,R2		;COMPARE BYTE FOR :
  F7AC   16FB           	JNE	HEXLOAD2
  F7AE   2F20 F146      	WRITE	@DOT		;DEBUG INFO
  F7B2   04C3           	CLR 	R3		;CLEAR CHECKSUM
  F7B4   2DA0 F7EE      	CALL	@NEXTBYTE		;GET RECORD LENGTH
  F7B8   D101           	MOVB	R1,R4
  F7BA   0984           	SRL	R4,8		;LENGTH IN R4
  F7BC   13F1           	JEQ	INST_EXIT		;WERE DONE
  F7BE   2DA0 F7EE      	CALL	@NEXTBYTE		;GET PAGE SETTING BYTE.
  F7C2   D241           	MOVB	R1,R9		;MOVE INTO PAGE/SEGMENT REGISTER
                        ;
                        ;	SHOW AND SET PAGE AND CORRECT FOR CHECKSUM (AB	R1,R3)
                        ;
  F7C4   70C1           	SB	R1,R3
  F7C6   2F20 F148      	WRITE	@PLUS
  F7CA   2C80           	SETPAGE			;SET PAGE/SEGMENT REGISTER ADDRESS
                        ;
  F7CC   2DA0 F808      HL_21	CALL	@NEXTADDR		;GET LOAD ADDRESS
  F7D0   C141           	MOV	R1,R5
  F7D2   2DA0 F7EE      	CALL	@NEXTBYTE		;GET RECORD TYPE
  F7D6   C104           HL_22	MOV	R4,R4		;IF RL=0 GO TO A13
  F7D8   1306           	JEQ	HL_23
  F7DA   2DA0 F7EE      	CALL	@NEXTBYTE
  F7DE   07C0           	LDD			;LONG DISTANCE DESTINATION WRITE
  F7E0   DD41           	MOVB	R1,*R5+		;STORE DATA IN MEMORY
  F7E2   0604           	DEC	R4		;REDUCE RECORD LENGTH
  F7E4   10F8           	JMP	HL_22
  F7E6   2DA0 F7EE      HL_23	CALL	@NEXTBYTE		;GET CHECKSUM BYTE
                        ;	MOVB	R3,R3		;CHECK FOR ZERO
  F7EA   13DC           	JEQ	HEXLOAD2
  F7EC   10D5           	JMP	HL_14
                        
  F7EE   04C2           NEXTBYTE:	CLR 	R2		;ACCUMULATOR
  F7F0   2F41           	READ	R1
  F7F2   2DA0 F818      	CALL	@CATOH		;CONVERT ASCII TO HEX
  F7F6   D081           	MOVB	R1,R2
  F7F8   0A42           	SLA	R2,4		;MOVE IT OVER
  F7FA   2F41           	READ	R1		;NEXT ASCII CHAR
  F7FC   2DA0 F818      	CALL	@CATOH
  F800   F081           	SOCB	R1,R2		;BYTE NOW IN R1
  F802   C042           	MOV	R2,R1
  F804   B0C1           	AB	R1,R3		;UPDATE CHECKSUM
  F806   2DC0           	RET
                        ;
  F808   2DA0 F7EE      NEXTADDR:	CALL	@NEXTBYTE
  F80C   C141           	MOV	R1,R5
  F80E   2DA0 F7EE      	CALL	@NEXTBYTE
  F812   06C1           	SWPB	R1
  F814   E045           	SOC	R5,R1
  F816   2DC0           	RET
                        ;
                        ;	ASCII TO HEX CONVERTER
                        ;
  F818   0281 3900      CATOH:	CI	R1,'9'*256
  F81C   1202           	JLE	CATOH_1
  F81E   0221 0900      	AI	R1,0900H		;ALPHA ADJUST
  F822   0241 0F00      CATOH_1	ANDI	R1,0F00H
  F826   2DC0           	RET
                        ;
                        ;---INITIALISE TMS9902 FOR BAUD RATE OF 19200:
                        ;   PROTOCOL SETTINGS
                        ; 	*BAUD RATE
                        ;	*8 BITS/CHARACTER
                        ;	*NO PARITY
                        ;	*2 STOP BITS
                        ;
  0080                  CRUBASE: 	EQU	0080H
  F828   0360           INITIAL:	RSET			;RSET
  F82A   02E0 0230      	LWPI	WORKSP		;USE MONITOR LOCAL WORKSPACE
  F82E   04CF           	CLR	R15		;CLEAR STATUS AND MAKE SURE BIT 8 IS ZERO
                        ;	LST	R15
  F830   020A 0500      	LI	SP,STACKP		;STACK FOR LOCAL MONITOR USE
                        ;
                        ;DISABLE ALL INTERRUPTS WHILE INITALISING
                        ;
  F834   020C 0080      	LI	R12,CRUBASE
  F838   1D1F           	SBO	31		;RESET TMS9902
  F83A   3220 F86A      	LDCR	@CTL02,8
  F83E   1E0D           	SBZ	13		;DO NOT SET INTERVAL REGISTER
  F840   04C3           	CLR	R3		;RESET LOOP COUNT
  F842   1F0F           TSTSP	TB	15		;SPACE
  F844   13FE           	JEQ	TSTSP		;NO JUMP BACK
  F846   0583           SPLOOP	INC	R3		;TIME THE START BIT
  F848   1F0F           	TB	15		;FALL OUT ON MARK
  F84A   16FD           	JNE	SPLOOP
                        ;
                        ;---TABLE SEARCH FOR BAUD RATES
                        ;	SET AT 19200 or BD57600
                        ;
                        ;	LI	R7,BD19200		;SET POINTER TO TABLE
  F84C   0207 F86C      	LI	R7,BD57600		;SET POINTER TO TABLE
  F850   05C7           	INCT	R7		;POINT TO THE NEXT WORD THAT HOLDS THE TMS9902 CODES
                        ;400	JMP	BDMATCH		;FORCE THE BAUD RATE TO BE 19200
                        ;
                        ; LOAD THE BAUD RATE VALUES
                        ;
                        
  F852   3317           BDMATCH	LDCR	*R7,12 		;INT RECV/TXMT DATA RATE
  F854   32D7           	LDCR	*R7,11
  F856   3607           	STCR	R7,8		;PULL OUT ANY JUNK
  F858   3607           	STCR	R7,8
                        ;
                        ; CLEAR PAGE ADDESSES AND REVERT TO PAGE 0
                        ;
  F85A   04C9           	CLR	R9		;CLEAR SEGEMENT AND SELECT PAGE 0
  F85C   020C 80C0      	LI	PORT,MEMBASE
  F860   3089           	LDCR	R9,BYTEWIDE		;GET PAGE VALUE FROM STEP ABOVE
                        ;
                        ; NOW ENTER THE TIBUG_MONITOR COMMANDS
                        ;
                        ;
  F862   06A0 F1BA      	BL	@INIT_VECTORS		;INITIALISE ALL XOP AND INTERRUPT VECTORS
  F866   0460 F03C      	B	@BANNER
                        ;
  F86A   43             CTL02	BYTE	43H		;43H FOR A 3 MHZ CLOCK 4B FOR A 4 MHZ CLOCK
  F86B   00             	EVEN
  F86C   0002 0009      BD57600	WORD	2,9H 		;BAUD RATE = 57600
  F870   0009 001A      BD19200 	WORD	9,1AH		;BAUD RATE = 19200
                        ;BD9600	WORD 	19,34H		;BAUD RATE = 9600
                        ;
                        
                        ;CLRRECV:	LI	R12,CRUBASE
                        ;	STCR	R0,8		;CLEAR INPUT
                        ;	SBZ	18		;SHOW WE RECEIVED CHARACTER
                        ;	RET
                        ;
                        ;---Place load vectors into FFFC & FFFE
                        ;
  FFFC                  	AORG	0FFFCH
  FFFC   0230           	WORD	WORKSP
  FFFE   F828           	WORD	INITIAL
                        ;
  0000                  	END

No error(s).
XOP14            F598  MASK15           F0DA  FDCSTATUS        EF3E  MON02            F05A  
LIST_REGA        F606  COUT             F26E  R14              000E  ERRMSG           F420  
LDS              0780  IDE_DRQ          0010  MOVE             F0E6  LIST_REG2        F622  
XOP10            F524  IGE_X            F2EA  INIT1            F1C4  DEBUG            2FC0  
LOWW             F0EC  FIND             F0E8  INIT_RAM         F1F2  PADDRC           F6F6  
IDE_CMD_READ     2000  LDD              07C0  IDE_DSC          0010  NEXTBYTE         F7EE  
XOP10A           F52A  OPEN             F6CA  XOP10B           F53A  WP               F748  
SECTMSG          F446  DMAADDR          00E0  PRINT            F0F0  SETBP            F0E0  
BSY1             F298  BUFFER           ED00  INTWP            00B0  BOOT_ADDR        F004  
XOP3A            F4C2  SSTEP            F0DE  DRQ_X            F35E  WP_REG           F654  
INTWP0           00B0  LIST_REGC        F618  INTWP2           00D0  IDE_GET_ERROR    F2D8  
INTWP4           00F0  SP               000A  INTWP6           0110  INTVEC           0000  
LIST_REG         F5D2  ST               000F  DRVMSG           F434  HL_13            F792  
PAGE             F262  HL_23            F7E6  XOP15_NAME       F5AA  PLUS             F148  
MESS00           F0F2  CMDTBL           F034  MESS02           F113  INIT3            F1DE  
MON01            F050  XOP12            F578  MESS04           F11E  SP_REG           F669  
RSET             F3CE  IDE_WR_LBA       F388  XOPTAB           F156  ST_REG           F65B  
LIST_REG1        F61E  TRACE            F0E2  WRITE            2F00  INTTAB           F196  
WBOOT            F200  WL11             F37C  REGIST2          F6A0  R12              000C  
XOP0             F450  XOPWP14          0210  XOP2             F48C  INTLV2           F3EE  
XOP4             F4C8  XOP12A           F57E  XOP6             F4EE  DRIVE_ID         F2BE  
INIT_VECTORS     F1BA  CTL02            F86A  XOP8             F50A  PRINT_REGS       F680  
FDC_DRQ          F3F6  IDE_HEAD         804C  R0               0000  INT1             F1B6  
R2               0002  INT7             F1B8  R4               0004  IDE_SEC_CNT      8044  
R6               0006  BD57600          F86C  R8               0008  XOPWP10          01D0  
CRLF             F038  DISC_INUSE       EF42  XOP15            F5A2  DMAPORT          00E8  
HEXTAB           F06A  IDE_READY        F28A  WRTRK            F284  CHAR             F0E4  
R15              000F  LOCAL_RAM        EF00  POP              2E40  IDE_IRQ          F2AE  
XOP11            F548  OUTPUT0          F710  HL_12            F784  PROMPT           F044  
BDMATCH          F852  GO               F67C  OPEN01           F6D2  IDE_READ_DATA    F360  
OPEN03           F6E8  SUBTAB           F0B0  R11              000B  RDREC            F27E  
INTSYS           F3CC  LOADERR          F14A  WP00             F750  TPA              0500  
XOP11B           F54E  MON03            F060  HEXIN            F122  DMACMD           00E2  
HEXIN0           F128  BDOSV            0086  HEXIN2           F13E  MON_PTR          0088  
RL11             F368  DRQ1             F352  IDE_DRDY         0040  STSREG           8000  
NEXTADDR         F808  BD19200          F870  IDE_DMARQ        F2B6  CR               000D  
INTTIMER         F400  MEMBASE          80C0  BANNER           F03C  CIN              F26A  
PUSHREG          2D00  XOP15_REGS       F5C6  SEEK             F3F0  RET              2DC0  
IDE_BASE_PORT    8040  NOTHEX           F574  XOP14A           F5A0  LBA              00A8  
HL_21            F7CC  BDOS             2C00  RDTRK            F282  REGIST0          F68C  
R10              000A  DEBUG_BUFFER     EF2A  XOPWP12          01F0  WORKSP           0230  
OUTPUT2          F728  CATOH            F818  RDID             F27C  INTAB            F09A  
XOP4A            F4CE  BOOT             F202  INTWP1           00C0  SWBANK           2CC0  
INTWP5           0100  XOPWP            0130  MONORG           F000  RETF             2C40  
IDE_DATA         8040  IDE_NOT_BUSY     F33C  MESS01           F10F  TSTSP            F842  
RHEX             2EC0  BMSG1            F242  DISC_PARAM       EF3E  XOPWP0           0130  
READ             2F40  XOPWP1           0140  RECAL            F27A  XOPWP2           0150  
XOP1             F460  XOPWP3           0160  XOP5             F4DC  XOPWP4           0170  
XOP9             F518  IDE_CMD_WRITE    3000  POPREG           2D40  XOPWP6           0190  
R3               0003  SETTIMER         F3D0  R7               0007  XOPWP5           0180  
CALL             2D80  XOPWP9           01C0  LIST_REGB        F612  XOPWP7           01A0  
INIT_MONITOR     F000  XOPWP8           01B0  INIT2            F1D6  INSTANT          F0EE  
OPEN00           F6CE  HL_14            F798  TIMEOUT          EF40  QBOOT            F678  
MESG             2F80  XOP13            F588  SELDSK           F276  IDE_CMD_RECAL    1000  
HEXIN1           F130  IDE_CYL_LSB      8048  DEBUG_NAME       EF20  R13              000D  
DOT              F146  XOPWP15          0220  READ_SECTOR      F2FE  STACKP           0500  
SPLOOP           F846  OUTPUT           F708  XOPWP16          0230  IDE_DWF          0020  
BOOT2            F236  SETPAGE          2C80  NUMTAB           F07A  XOP13A           F58C  
BSY2             F340  BYTEWIDE         0002  XOP5A            F4E0  LIST_EXIT        F64E  
INTWP7           0120  PC_REG           F662  FDC_RWINT        F3FE  PORT             000C  
EA_REG           F671  BOOT1            F226  IDE_MSG1         F2EC  FDC1797          8000  
XOP3             F49A  SELMUX           0000  HEXLOAD          F760  LF               000A  
R5               0005  IDE_COMMAND      804E  HEXLOAD2         F7A4  XOPWP11          01E0  
HL_22            F7D6  BYTSEC           0200  OPEN02           F6DE  IDE_CMD_INIT     9100  
XOP11A           F54A  IDE_WRITE_DATA   F374  OUTPUT3          F73A  WRREC            F286  
WHEX             2E80  MASK3            F0DC  IDE_CYL_MSB      804A  IDE_BSY          0080  
IDE_CONTROL      804C  TIME2            F41E  XOP1A            F486  OUTPUT1          F71E  
XOPVEC           0040  CATOH_1          F822  GOTONE           F56A  IDE_CMD_SUP      E100  
XOP7             F4FE  IDE_ERR          0001  R9               0009  IDE_ERROR        8042  
XCUTE            F0EA  RDY1             F2A4  TRKMSG           F43D  IDE_WAIT_DRQ     F34A  
IDE_CMD_SDOWN    E000  WRITE_SECTOR     F31E  INST_EXIT        F7A0  MON00A           F6F2  
MESS03           F116  REGIST1          F69C  R1               0001  XOP15_MAIN       F5B8  
XOPWP13          0200  IDE_STATUS       804E  CRUBASE          0080  RAM_SIZE         0006  
INITIAL          F828  INTWP3           00E0  IDE_CMD_ID       EC00  BMSG2            F252  
IDE_SECTOR       8046  PUSH             2E00  
